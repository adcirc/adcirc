!----------------------------------------------------------------------------

!                           MODULE DECOMP

!----------------------------------------------------------------------------

!                  For use with ADCPREP Version 1.6 (  5/21/03 )

!                     current for ADCIRC v43.03   5/20/2003
!----------------------------------------------------------------------------

    SUBROUTINE DECOMP()
    USE pre_global

!---------------------------------------------------------------------------C
!                     (  Serial Version 1.1  5/04/99  )                     C
!                                                                           C
!  Decomposes the ADCIRC grid into NPROC subdomains.                        C
!  The Decomposition Variables are defined in the include file adcprep.inc  C
!  This version is compatible with ADCIRC version 34.03                     C
!                                                                           C
!  12/14/98 vjp  Added interface to METIS 4.0                               C
!   3/10/99 vjp  Rewritten to allow Weir-node pairs to both be ghost nodes  C
!   4/05/99 vjp  Fixed bugs in metis interface routine                      C
!                                                                           C
!---------------------------------------------------------------------------C

    INTEGER :: N1, N2, N3, KMIN, VTMAX
    INTEGER :: I,J,JD,JG,JP,K,M,ITEMP,ITEMP2,IPR,IPR1,ICNT
    INTEGER :: ITOT,IEL,IELG,ILNODE,ILNODE2,IPROC,IPROC2
    INTEGER :: IG1,IG2,IG3,IL1,IL2,IL3,PE1,PE2,PE3
    INTEGER :: I1,DISC,BBN,IBP,NCOUNT
    INTEGER :: INDX,INDX2, KK
    INTEGER,ALLOCATABLE :: ITVECT(:)
    CHARACTER PE*6
    CHARACTER(6), PARAMETER :: STRINGGLOBAL = "GLOBAL"

    VTMAX = 24*MNP
    ALLOCATE ( ITVECT(VTMAX) )

!   STEP 1:
!-- Use Partition of nodes to compute the number of Resident Nodes
!   to be assigned to each processor.
!-- Then construct Local-to-Global and Global-to-Local Node maps
!   for resident nodes: IMAP_NOD_LG(I,PE),  IMAP_NOD_GL(1:2,I)

    DO I=1, NPROC             ! Use METIS 4.0  Partition
        NOD_RES_TOT(I) = 0
    ENDDO
    DO J=1, NNODG
        NCOUNT = NOD_RES_TOT(PROC(J))+1
        IMAP_NOD_GL(1,J) = PROC(J)
        IMAP_NOD_GL(2,J) = NCOUNT
        IMAP_NOD_LG(NCOUNT,PROC(J)) = J
        NOD_RES_TOT(PROC(J)) = NCOUNT
    ENDDO
!     DO I = 1, NNODG
!        print *, I, IMAP_NOD_GL(1,I)
!     ENDDO

! STEP 2:
!  Construct Local-to-Global Element Map: IMAP_EL_LG(:,PE)
!  Add an element to the map if it has an resident node

    DO I = 1,NPROC
        NELP(I) = 0
        DO K = 1,NELG
            N1 = NNEG(1,K)
            N2 = NNEG(2,K)
            N3 = NNEG(3,K)
            PE1 = IMAP_NOD_GL(1,N1) ! Is any vertex a resident node?
            PE2 = IMAP_NOD_GL(1,N2)
            PE3 = IMAP_NOD_GL(1,N3)
            IF ((PE1 == I) .OR. (PE2 == I) .OR. (PE3 == I)) THEN
                NELP(I) = NELP(I) + 1
                IMAP_EL_LG(NELP(I),I) = K
            ENDIF
        ENDDO
        IF (NELP(I) > MNEP) STOP 'NELP(I) > MNEP'
    ENDDO

! STEP 3:
!--Using Local-to-Global Element map
!  Construct Local-to-Global Node map:  IMAP_NOD_LG(I,PE)
!  and reconstruct Global-to-Local map for resident nodes

    DO I = 1,NPROC
        ITOT = 0
        DO J = 1,NELP(I)
            IEL = IMAP_EL_LG(J,I)
            DO M=1, 3
                ITOT = ITOT + 1
                ITVECT(ITOT) = NNEG(M,IEL)
            ENDDO
        ENDDO
        ITEMP = ITOT
        IF (ITOT > VTMAX) stop 'step3 decomp'
        CALL SORT(ITEMP,ITVECT) ! Sort and remove multiple occurrences
        ITOT = 1
        IMAP_NOD_LG(1,I) = ITVECT(1)
        IF (IMAP_NOD_GL(1,ITVECT(1)) == I) THEN
            IMAP_NOD_GL(2,ITVECT(1))=1
        ENDIF
        DO J = 2, ITEMP
            IF (ITVECT(J) /= IMAP_NOD_LG(ITOT,I)) THEN
                ITOT = ITOT + 1
                IMAP_NOD_LG(ITOT,I) = ITVECT(J)
                IF (IMAP_NOD_GL(1,ITVECT(J)) == I) THEN
                    IMAP_NOD_GL(2,ITVECT(J))=ITOT
                ENDIF
            ENDIF
        ENDDO
        NNODP(I) = ITOT
        IF (NNODP(I) > MNPP) STOP 'NNODP > MNPP'
    ENDDO
!     print *, "Number of Nodes Assigned to PEs"
!     DO I=1, NPROC
!        print *, I-1, NNODP(I)
!        DO J=1, NNODP(I)
!           print *, J,IMAP_NOD_LG(J,I)
!        ENDDO
!     ENDDO

! STEP 4:
!--If there are any global Weir-node pairs, construct
!  Local-to-Global Weir Node maps: WEIRP_LG(:,PE), WEIRDP_LG(:,PE)
!  Rule: if a global Weir node is assigned ( either as a resident or ghost node )
!        then make it and its dual a local Weir-node pair

    IF (NWEIR > 0) THEN
        DO I=1, NPROC
            ITOT = 0
        
        ! Seizo 2008.07.14
            DO J = 1, NWEIR
                INDX = WEIR(J)
                INDX2= WEIRD(J)
                DO K = 1, NNODP(I)
                    N1 = IMAP_NOD_LG(K,I)
                    IF( (N1 == INDX) .OR. (N1 == INDX2) ) THEN
                        ITOT = ITOT + 1
                        ITVECT(ITOT) = J
                        EXIT
                    ENDIF
                ENDDO
            ENDDO
        
        ! eizo 2008.07.14          DO J = 1,NNODP(I)
        ! eizo 2008.07.14             CALL SEARCH(WEIR,NWEIR,IMAP_NOD_LG(J,I),INDX)
        ! eizo 2008.07.14             IF (INDX.NE.0) THEN
        ! eizo 2008.07.14               ITOT = ITOT+1
        ! eizo 2008.07.14               ITVECT(ITOT) = INDX
        ! eizo 2008.07.14             ENDIF
        ! eizo 2008.07.14             CALL SEARCH(WEIRD,NWEIR,IMAP_NOD_LG(J,I),INDX2)
        ! eizo 2008.07.14             IF (INDX2.NE.0) THEN
        ! eizo 2008.07.14               ITOT = ITOT+1
        ! eizo 2008.07.14               ITVECT(ITOT) = INDX2
        ! eizo 2008.07.14             ENDIF
        ! eizo 2008.07.14          ENDDO
            NWEIRP(I) = 0
            ITEMP = ITOT
            IF (ITOT > VTMAX) stop 'step4 decomp'
            IF (ITEMP > 1) THEN
                CALL SORT(ITEMP,ITVECT)
                ITOT=1
                INDX = ITVECT(1)
                WEIRP_LG(ITOT,I)  = WEIR(INDX)
                WEIRDP_LG(ITOT,I) = WEIRD(INDX)
                DO J = 2,ITEMP
                    IF (ITVECT(J) /= INDX) THEN
                        INDX = ITVECT(J)
                        ITOT = ITOT+1
                        WEIRP_LG(ITOT,I)  = WEIR(INDX)
                        WEIRDP_LG(ITOT,I) = WEIRD(INDX)
                    ENDIF
                ENDDO
                NWEIRP(I) = ITOT
            ENDIF
        !       DO J = 1, NWEIRP(I)
        !          print *, J, WEIRP_LG(J,I),WEIRDP_LG(J,I)
        !       ENDDO
        !       print *, "decomp: Number of WEIR node-pairs on PE",I-1,
        !    &           " = ",NWEIRP(I)
        ENDDO
    ELSE
        DO I=1, NPROC
            NWEIRP(I) = 0
        !          print *, "decomp: Number of WEIR node-pairs on PE",I-1,
        !    &              " = ",NWEIRP(I)
        ENDDO
    ENDIF

! STEP 5:
!--If there are any global Weir-node pairs,
!  Re-construct Local-to-Global Element Map: IMAP_EL_LG(:,PE)
!  Rule:  Add an element if it has an resident node or
!         has the dual Weir node of a resident or ghost node

    EL_SHARE(:) = -1
    IF (NWEIR > 0) THEN
        DO I = 1,NPROC
            NELP(I) = 0
        !           print *, "PE = ",I-1
            DO K = 1,NELG
                N1 = NNEG(1,K)
                N2 = NNEG(2,K)
                N3 = NNEG(3,K)
                PE1 = IMAP_NOD_GL(1,N1)   ! Is any vertex a resident node?
                PE2 = IMAP_NOD_GL(1,N2)
                PE3 = IMAP_NOD_GL(1,N3)   ! belong to a Weir-node pair ?
                CALL SEARCH3(WEIRP_LG(1,I),NWEIRP(I),N1,N2,N3,INDX)
                CALL SEARCH3(WEIRDP_LG(1,I),NWEIRP(I),N1,N2,N3,INDX2)
            ! if any vertex is a resident vertex, or is a weir node
            ! paired to a resident vertex
                IF ((PE1 == I) .OR. (PE2 == I) .OR. (PE3 == I) &
                 .OR. (INDX /= 0) .OR. (INDX2 /= 0)) THEN
                !                 print *, K, PE1,PE2,PE3,INDX,INDX2
                ! increment the number of elements on this subdomain
                    NELP(I) = NELP(I) + 1
                ! add the fulldomain element number to the mapping;
                ! make it negative if some other subdomain has already
                ! listed it as a resident element (the first subdomain
                ! that has an element that maps to a fulldomain element
                ! claims it as a resident; the next subdomain(s) that
                ! have an element that maps to this fulldomain element
                ! will have that element number listed as negative,
                ! or "ghost" in their mapping tables (first come, first
                ! served)
                    IF (EL_SHARE(K) > -1) THEN
                        IMAP_EL_LG(NELP(I),I) = -K
                    ELSE
                        IMAP_EL_LG(NELP(I),I) = K
                    ENDIF
                ! in any case, record the fact that a subdomain has already
                ! claimed this element as a resident
                    EL_SHARE(K) = I
                ENDIF
            ENDDO
            IF (NELP(I) > MNEP) STOP 'NELP(I) > MNEP'
        !           print *, "Number of elements on PE",I-1," = ",NELP(I)
        !           DO J = 1, NELP(I)
        !              print *, J, IMAP_EL_LG(J,I)
        !           ENDDO
        ENDDO
    ELSE
    ! jgf: If there are no weirs, then go back through the element
    ! mapping and leave the first subdomain element that maps to a
    ! particular fulldomain element as a "resident" with a positive
    ! fulldomain element number in IMAP_EL_LG, while giving subsequent
    ! subdomain elements that map to that same fulldomain element
    ! a negative value in IMAP_EL_LG (marking them as "ghosts").
        DO I=1,NPROC
            DO J=1,NELP(I)
                K = IMAP_EL_LG(J,I)
                IF (EL_SHARE(K) > -1) THEN
                    IMAP_EL_LG(J,I) = -IMAP_EL_LG(J,I)
                ENDIF
                EL_SHARE(K) = I
            END DO
        END DO
    ENDIF

! STEP 6:
!--Using Local-to-Global Element map
!  Construct Local-to-Global Node map:  IMAP_NOD_LG(I,PE)
!  and reconstruct Global-to-Local map for resident nodes

    DO I = 1,NPROC
        ITOT = 0
        DO J = 1,NELP(I)
            IEL = abs(IMAP_EL_LG(J,I))
            DO M=1, 3
                ITOT = ITOT + 1
                ITVECT(ITOT) = NNEG(M,IEL)
            ENDDO
        ENDDO
        ITEMP = ITOT
        IF (ITOT > VTMAX) stop 'step6 decomp'
        CALL SORT(ITEMP,ITVECT) ! Sort and remove multiple occurrences
        ITOT = 1
        IMAP_NOD_LG(1,I) = ITVECT(1)
        IF (IMAP_NOD_GL(1,ITVECT(1)) == I) THEN
            IMAP_NOD_GL(2,ITVECT(1))=1
        ENDIF
        DO J = 2, ITEMP
            IF (ITVECT(J) /= IMAP_NOD_LG(ITOT,I)) THEN
                ITOT = ITOT + 1
                IMAP_NOD_LG(ITOT,I) = ITVECT(J)
                IF (IMAP_NOD_GL(1,ITVECT(J)) == I) THEN
                    IMAP_NOD_GL(2,ITVECT(J))=ITOT
                ENDIF
            ENDIF
        ENDDO
        NNODP(I) = ITOT
        IF (NNODP(I) > MNPP) STOP 'NNODP > MNPP'
    ENDDO
!     print *, "Number of Nodes Assigned to PEs"
!     DO I=1, NPROC
!        print *, I-1, NNODP(I)
!        DO J=1, NNODP(I)
!           print *, J,IMAP_NOD_LG(J,I)
!        ENDDO
!     ENDDO

! STEP 7:
!--Construct Local Element Connectivity Table for each PE: NNEP(3,I,PE)

! loop over subdomains
    DO I = 1,NPROC
    ! ITEMP = number of nodes on this subdomain
        ITEMP = NNODP(I)
    ! loop over local nodes on this subdomain
        DO J = 1,NNODP(I)
        ! make array of corresponding fulldomain node numbers
            ITVECT(J) = IMAP_NOD_LG(J,I)
        ENDDO
    ! loop over elements on this subdomain
        DO J = 1,NELP(I)
        ! grab fulldomain element number, whether ghost or resident element
            IELG = abs(IMAP_EL_LG(J,I))
        ! loop over nodes on this element
            DO M = 1,3
            ! get fulldomain node number on this element
                IG1 = NNEG(M,IELG)
            ! look for the fulldomain node number in the list of
            ! fulldomain nodes in this domain
                CALL LOCATE(ITVECT,ITEMP,IG1,K)
            ! if the fulldomain node number on this element below
            ! the range of fulldomain node numbers on this subdomain...
                IF (K <= 0) THEN
                ! if the next index value matches
                    IF (IMAP_NOD_LG(K+1,I) == IG1) THEN
                    ! add the next index value to the local element
                    ! connectivity table
                        NNEP(M,J,I) = K+1
                    ELSE
                        STOP 'ERROR IN IMAP_NOD_LG'
                    ENDIF
                ELSEIF (K >= NNODP(I))THEN
                    IF (IMAP_NOD_LG(K,I) == IG1) THEN
                        NNEP(M,J,I) = K
                    ELSE
                        STOP 'ERROR IN IMAP_NOD_LG'
                    ENDIF
                ELSE
                    IF (IMAP_NOD_LG(K,I) == IG1) THEN
                        NNEP(M,J,I) = K
                    ELSEIF (IMAP_NOD_LG(K+1,I) == IG1) THEN
                        NNEP(M,J,I) = K+1
                    ELSE
                        STOP 'ERROR IN IMAP_NOD_LG'
                    ENDIF
                ENDIF
            ENDDO
        ENDDO
    ENDDO

! STEP 8:
!--Compute the number of communicating PEs and their
!  list for each PE:  NUMM_COMM_PE(PE) and COMM_PE_NUM(IPE,PE)


! ITVECT is a list of the neighboring subdomain numbers
! corresponding to this subdomain's ghost nodes

! loop over subdomains
    DO I = 1,NPROC
        NUM_COMM_PE(I) = 0  ! zero the num of neighboring subdomains
        ITEMP = 0           ! zero the number of ghost nodes on this subdomain
    ! loop over subdomain nodes
        DO J = 1,NNODP(I)
        ! get corresponding fulldomain node number
            INDX = IMAP_NOD_LG(J,I)
        ! use fulldomain node number to get number of subdomain
        ! where this node is a resident
            IPR = IMAP_NOD_GL(1,INDX)
        ! if the subdomain of residence is not this one
            IF (IPR /= I)THEN
            ! increment number of ghost nodes on this subdomain
                ITEMP = ITEMP + 1
            ! add the subdomain number to which the ghost node belongs
            ! to the list of neighboring subdomains
                ITVECT(ITEMP) = IPR
            ENDIF
        ENDDO
        IF (ITEMP == 0) THEN
            NUM_COMM_PE(I) = 0
        ELSE
            IF (ITEMP > VTMAX) stop 'step8 decomp'
        ! sort the list of neighboring subdomains numbers in ascending order
            CALL SORT(ITEMP,ITVECT)
        ! set the first neighboring subdomain
            COMM_PE_NUM(1,I) = ITVECT(1)
        ! reset the subdomain neighbor counter
            ITOT = 1
        ! loop over the subdomain numbers of the ghost nodes
        ! in this subdomain
            DO J = 1,ITEMP
            ! if the subdomain number is not a duplicate
                IF (ITVECT(J) /= COMM_PE_NUM(ITOT,I)) THEN
                ! increment the number of neighboring subdomains
                    ITOT = ITOT + 1
                ! record the number of the neighboring subdomain
                    COMM_PE_NUM(ITOT,I) = ITVECT(J)
                ENDIF
            ENDDO
        ! set the total number of neighbor subdomains for this
        ! subdomain
            NUM_COMM_PE(I) = ITOT
            IF (NUM_COMM_PE(I) > MNPROC) STOP 'NUM_COMM_PE>MNPROC'
        ENDIF
    ENDDO

! Casey 110518: Added this change from Seizo.
!     Send <=> Receive Proc CHECK & CORRECTION !st3 06.19.2009
! loop over subdomains
    DO I = 1, NPROC
    ! loop over subdomains neighboring this one
        DO J = 1, NUM_COMM_PE(I)
        ! get neighboring subdomain number
            INDX = COMM_PE_NUM(J,I)
        ! zero the flag indicating that this subdomain is listed
        ! as the neighboring subdomain's neighbor
            ITOT = 0
        ! loop over the subdomains neighboring this neighbor
            DO K = 1, NUM_COMM_PE(INDX)
            ! get the neighbor's neighboring subdomain number
                INDX2 = COMM_PE_NUM(K,INDX)
            ! set a flag if this subdomain is listed as the
            ! neighbor's neighbor
                IF( I == INDX2 ) ITOT = 1
            ENDDO
        ! if the flag was not set
            IF( ITOT == 0 ) THEN
            ! increment neighbor's number of subdomain neighbors
                NUM_COMM_PE(INDX) = NUM_COMM_PE(INDX) + 1
            ! add this subdomain to this list of neighbors for
            ! the neighboring subdomain
                COMM_PE_NUM( NUM_COMM_PE(INDX), INDX )  = I
            ! I don't see how this can happen, so I am adding a
            ! warning message to provide an alert when it does
            ! so that I can examine it more closely.
                write(6,'(a,i0,a,i0,a)') 'WARNING: Subdomain ',I, &
                ' added to the list of subdomain neighbors of subdomain ', &
                INDX,'.'
            ENDIF
        ENDDO
    ENDDO

! STEP 9:
!--Construct a Global-to-Local node mapping: IMAP_NOD_GL2(*,J)
!  This is not a function, but is rather a relation
!  It works for both resident and ghost nodes

    DO I = 1,NNODG
        ITOTPROC(I) = 0
    ENDDO
    DO I = 1,NPROC
        DO J = 1,NNODP(I)
            INDX = IMAP_NOD_LG(J,I)
            ITOTPROC(INDX) = ITOTPROC(INDX) + 1
            IF (ITOTPROC(INDX) > MNPROC)THEN
                WRITE(6,*)'Some nodes belong to more processors', &
                ' than MNPROC'
                STOP
            ENDIF
            ITEMP = (ITOTPROC(INDX)-1)*2 + 1
            IMAP_NOD_GL2(ITEMP,INDX) = I
            IMAP_NOD_GL2(ITEMP+1,INDX) = J
        ENDDO
    ENDDO
!     print *, "Global Nodes assigned to more than one PE"
!     do J=1, NNODG
!        if (ITOTPROC(J).GT.1) print *, J, ITOTPROC(J)
!     enddo

! STEP 10:
!--Print Summary of Decomposition

    print *, "Decomposition Data"
    print *, "DOMAIN  RES_NODES  GHOST_NODES  TOT_NODES  ELEMENTS"
    print *, "------  ---------  -----------  ---------  --------"
    WRITE(*,90) STRINGGLOBAL,NNODG,NELG
    DO I=1, NPROC
        PE(1:6) = 'PE0000'
        CALL IWRITE(PE,3,6,I-1)
        WRITE(6,92) PE, NOD_RES_TOT(I),NNODP(I)-NOD_RES_TOT(I), &
        NNODP(I),NELP(I)
    ENDDO
    90 FORMAT(1X,A6,25X,I9,2X,I9)
    92 FORMAT(1X,A6,1X,I9,2X,I9,4X,I9,2X,I9)

    RETURN
    END SUBROUTINE DECOMP


    SUBROUTINE DOMSIZE()
    USE pre_global

!---------------------------------------------------------------------------C
!                   (  Serial Version 1.0  12/20/99 vjp )                   C
!                                                                           C
!  Takes dry run through the domain decomp to determine the max number of   C
!  nodes and elements assigned to any subdomain to determine MNPP and MNEP. C
!                                                                           C
!---------------------------------------------------------------------------C

    INTEGER :: N1,N2,N3,VTMAX
    INTEGER :: I,J,K,M,ITEMP
    INTEGER :: ITOT,IEL,IELG,ILNODE,ILNODE2,IPROC
    INTEGER :: IG1,IG2,IG3,IL1,IL2,IL3,PE1,PE2,PE3
    INTEGER :: INDX,INDX2
    INTEGER :: RESNODE,NODES,NELEM,ONELEM,NLWEIR

    INTEGER,ALLOCATABLE :: ITVECT(:)
    INTEGER,ALLOCATABLE :: NODE_LG(:)
    INTEGER,ALLOCATABLE :: NODE_GL1(:)
    INTEGER,ALLOCATABLE :: NODE_GL2(:)
    INTEGER,ALLOCATABLE :: ELEM_LG(:)
    INTEGER,ALLOCATABLE :: LWEIR_LG(:),LWEIRD_LG(:)

    VTMAX = 24*MNP
    ALLOCATE ( ITVECT(VTMAX) )
    ALLOCATE ( NODE_LG(MNP) )
    ALLOCATE ( NODE_GL1(MNP) )
    ALLOCATE ( NODE_GL2(MNP) )
    ALLOCATE ( LWEIR_LG(MNP),LWEIRD_LG(MNP) )
    ALLOCATE ( ELEM_LG(MNE) )

    MNPP = 0
    MNEP = 0

    DO 1000 IPROC=1, NPROC
    
    !   STEP 1:
    !-- Use Partition of nodes to compute the number of Resident Nodes
    !   to be assigned to each processor.
    !-- Then construct Local-to-Global and Global-to-Local Node maps
    !   for resident nodes
    
    
        DO J=1, MNP
            NODE_GL1(J) = 0
            NODE_GL2(J) = 0
            LWEIR_LG(J) = 0
            LWEIRD_LG(J) = 0
        ENDDO
    
        DO J=1, MNE
            ELEM_LG(J) = 0
        ENDDO
    
        RESNODE = 0
        NODES   = 0
        DO J=1, NNODG
            IF (IPROC == PROC(J)) THEN
                RESNODE = RESNODE+1
                NODE_GL1(J) = PROC(J)
                NODE_GL2(J) = RESNODE
                NODE_LG(RESNODE) = J
            ENDIF
        ENDDO
    !     DO I = 1, NNODG
    !        print *, I, NODE_GL1(I)
    !     ENDDO

    ! STEP 2:
    !  Construct Local-to-Global Element Map
    !  Add an element to the map if it has an resident node

        NELEM   = 0
        DO K = 1,NELG
            N1 = NNEG(1,K)
            N2 = NNEG(2,K)
            N3 = NNEG(3,K)
            PE1 = NODE_GL1(N1) ! Is any vertex a resident node?
            PE2 = NODE_GL1(N2)
            PE3 = NODE_GL1(N3)
            IF ((PE1 == IPROC) .OR. (PE2 == IPROC) .OR. (PE3 == IPROC)) THEN
                NELEM = NELEM+1
                ELEM_LG(NELEM) = K
            ENDIF
        ENDDO

    ! STEP 3:
    !--Using Local-to-Global Element map
    !  reconstruct Local-to-Global Node map
    !  and Global-to-Local map for resident nodes
    
        ITOT = 0
        DO J = 1,NELEM
            IEL = ELEM_LG(J)
            DO M=1, 3
                ITOT = ITOT + 1
                ITVECT(ITOT) = NNEG(M,IEL)
            ENDDO
        ENDDO
        ITEMP = ITOT
        IF (ITOT > VTMAX) stop 'step3 decomp'
        CALL SORT(ITEMP,ITVECT) ! Sort and remove multiple occurrences
        ITOT = 1
        NODE_LG(1) = ITVECT(1)
        IF (NODE_GL1(ITVECT(1)) == IPROC) THEN
            NODE_GL2(ITVECT(1))=1
        ENDIF
        DO J = 2, ITEMP
            IF (ITVECT(J) /= NODE_LG(ITOT)) THEN
                ITOT = ITOT + 1
                NODE_LG(ITOT) = ITVECT(J)
                IF (NODE_GL1(ITVECT(J)) == IPROC) THEN
                    NODE_GL2(ITVECT(J))=ITOT
                ENDIF
            ENDIF
        ENDDO
        NODES = ITOT


    ! STEP 4:
    !--If there are any global Weir-node pairs, construct
    !  Local-to-Global Weir Node maps
    !  Rule: if a global Weir node is assigned ( as resident or ghost node )
    !        then make it and its dual a local Weir-node pair
        IF (NWEIR > 0) THEN
            ITOT = 0
        ! Seizo 2008.07.14
            DO J = 1, NWEIR
                INDX = WEIR(J)
                INDX2= WEIRD(J)
                DO K = 1, NODES
                    N1 = NODE_LG(K)
                    IF( (N1 == INDX) .OR. (N1 == INDX2) ) THEN
                        ITOT = ITOT + 1
                        ITVECT(ITOT) = J
                        EXIT
                    ENDIF
                ENDDO
            ENDDO

        ! eizo 2008.07.14       DO J = 1,NODES
        ! eizo 2008.07.14          CALL SEARCH(WEIR,NWEIR,NODE_LG(J),INDX)
        ! eizo 2008.07.14          IF (INDX.NE.0) THEN
        ! eizo 2008.07.14            ITOT = ITOT+1
        ! eizo 2008.07.14            ITVECT(ITOT) = INDX
        ! eizo 2008.07.14          ENDIF
        ! eizo 2008.07.14          CALL SEARCH(WEIRD,NWEIR,NODE_LG(J),INDX2)
        ! eizo 2008.07.14          IF (INDX2.NE.0) THEN
        ! eizo 2008.07.14            ITOT = ITOT+1
        ! eizo 2008.07.14            ITVECT(ITOT) = INDX2
        ! eizo 2008.07.14          ENDIF
        ! eizo 2008.07.14       ENDDO
            NLWEIR  = 0
            ITEMP = ITOT
            IF (ITOT > VTMAX) stop 'step4 decomp'
            IF (ITEMP > 1) THEN
                CALL SORT(ITEMP,ITVECT)
                ITOT=1
                INDX = ITVECT(1)
                LWEIR_LG(ITOT)  = WEIR(INDX)
                LWEIRD_LG(ITOT) = WEIRD(INDX)
                DO J = 2,ITEMP
                    IF (ITVECT(J) /= INDX) THEN
                        INDX = ITVECT(J)
                        ITOT = ITOT+1
                        LWEIR_LG(ITOT)  = WEIR(INDX)
                        LWEIRD_LG(ITOT) = WEIRD(INDX)
                    ENDIF
                ENDDO
                NLWEIR = ITOT
            ENDIF
        ELSE
            NLWEIR = 0
        ENDIF
    !     print *, "domsize: Number of WEIR node-pairs on PE",IPROC-1,
    !    &         " = ",NLWEIR
        IF (NLWEIR > NWEIR) THEN
            print *, "error in domsize: "
            print *, "local number of weir-pairs exceeds total"
            stop
        ENDIF

    ! STEP 5:
    !--If there are any global Weir-node pairs,
    !  Re-construct Local-to-Global Element Map: IMAP_EL_LG(:,PE)
    !  Rule:  Add an element if it has an resident node or
    !         has the dual Weir node of a resident or ghost node

        ONELEM = NELEM     ! Save NELEM for PEs with no WEIR-pairs
        NELEM  = 0
        IF (NLWEIR > 0) THEN
            DO K = 1,NELG
                N1 = NNEG(1,K)
                N2 = NNEG(2,K)
                N3 = NNEG(3,K)
                PE1 = NODE_GL1(N1)   ! Is any vertex a resident node?
                PE2 = NODE_GL1(N2)
                PE3 = NODE_GL1(N3)   ! belong to a Weir-node pair ?
                CALL SEARCH3(LWEIR_LG(1),NLWEIR,N1,N2,N3,INDX)
                CALL SEARCH3(LWEIRD_LG(1),NLWEIR,N1,N2,N3,INDX2)
                IF ((PE1 == IPROC) .OR. (PE2 == IPROC) .OR. (PE3 == IPROC) &
                 .OR. (INDX /= 0) .OR. (INDX2 /= 0)) THEN
                    NELEM = NELEM + 1
                    ELEM_LG(NELEM) = K
                ENDIF
            ENDDO
        
        ENDIF

    ! STEP 6:
    !--Using Local-to-Global Element map, reconstruct Local-to-Global Node map
    
        IF (NELEM == 0) NELEM = ONELEM   ! if necessary restore old nelem
        ITOT = 0
        DO J = 1,NELEM
            IEL = ELEM_LG(J)
            DO M=1, 3
                ITOT = ITOT + 1
                ITVECT(ITOT) = NNEG(M,IEL)
            ENDDO
        ENDDO
        ITEMP = ITOT
        IF (ITOT > VTMAX) stop 'step6 decomp'
        CALL SORT(ITEMP,ITVECT) ! Sort and remove multiple occurrences
        ITOT = 1
        NODE_LG(1) = ITVECT(1)
        DO J = 2, ITEMP
            IF (ITVECT(J) /= NODE_LG(ITOT)) THEN
                ITOT = ITOT + 1
                NODE_LG(ITOT) = ITVECT(J)
            ENDIF
        ENDDO
    
        NODES = ITOT
        IF (NODES > MNPP) MNPP = NODES
    !     print *, "Number of nodes on PE",IPROC-1," = ",NODES
        IF (NELEM > MNEP) MNEP = NELEM
    !     print *, "Number of elements on PE",IPROC-1," = ",NELEM

    1000 END DO

    DEALLOCATE ( ITVECT,NODE_LG,NODE_GL1,NODE_GL2,ELEM_LG, &
    LWEIR_LG,LWEIRD_LG )

    print *, " Setting MNPP = ",MNPP
    print *, " Setting MNEP = ",MNEP

    RETURN
    END SUBROUTINE DOMSIZE






    SUBROUTINE SORT(N,RA)
    IMPLICIT NONE
    INTEGER :: N, L, IR, RRA, I, J
    INTEGER :: RA(N)

!---------------------------------------------------------------------------
!  Sorts array RA of length N into ascending order using Heapsort algorithm.
!  N is input; RA is replaced on its output by its sorted rearrangement.
!  Ref: Numerical Recipes
!---------------------------------------------------------------------------

    L = N/2 + 1
    IR = N
    10 CONTINUE
    IF (L > 1)THEN
        L=L-1
        RRA = RA(L)
    ELSE
        RRA=RA(IR)
        RA(IR)=RA(1)
        IR=IR-1
        IF (IR == 1) THEN
            RA(1)=RRA
            RETURN
        ENDIF
    ENDIF
    I=L
    J=L+L
    20 IF (J <= IR) THEN
        IF (J < IR) THEN
            IF(RA(J) < RA(J+1)) J=J+1
        ENDIF
        IF (RRA < RA(J)) THEN
            RA(I)=RA(J)
            I=J
            J=J+J
        ELSE
            J=IR+1
        ENDIF
        GO TO 20
    ENDIF
    RA(I)=RRA
    GO TO 10
    END SUBROUTINE SORT

    SUBROUTINE LOCATE(XX,N,X,J)
    IMPLICIT NONE
    INTEGER :: JM,JL,JU,J,N,X,XX(N)

!--Given an array XX of length N, and given a value X, returns a value J
!--such that X is between XX(J) and XX(J+1). XX must be monotonic, either
!--increasing or decreasing. J=0 or J=N is returned to indicate that X is out
!--of range.
!--
!--NUMERICAL RECIPES - The Art of Scientific Computing [FORTRAN Version]

!--Initialize lower and upper limits
    JL = 0
    JU = N+1

!--If we are not done yet, compute a mid-point, and replace either the lower
!--limit or the upper limit, as appropriate.

    10 IF(JU-JL > 1)THEN
        JM = (JU+JL)/2
        IF((XX(N) > XX(1)).EQV.(X > XX(JM)))THEN
            JL = JM
        ELSE
            JU = JM
        ENDIF
    !--Repeat until the test condition 10 is satisfied.
        GO TO 10
    ENDIF
!--Then set the output and return.
    J = JL
    RETURN
    END SUBROUTINE LOCATE

    SUBROUTINE SEARCH3(MAP,LENG,N1,N2,N3,INDX)
    INTEGER :: MAP(*),LENG,N1,N2,N3,INDX,IP
! jp  rewritten 5/3/99
    INDX = 0
    DO I=1,LENG
        IP = MAP(I)
        IF (IP == N1 .OR. IP == N2 .OR. IP == N3) THEN
            INDX = I
            GOTO 99
        ENDIF
    ENDDO
    99 RETURN
    END SUBROUTINE SEARCH3

    SUBROUTINE SEARCH(MAP,N,TARGET,INDX)
    INTEGER :: MAP(*),N,TARGET,INDX,I

    INDX = 0
    IF (N == 0) GOTO 99
    DO I=1,N
        IF (MAP(I) == TARGET) THEN
            INDX = I
            GOTO 99
        ENDIF
    ENDDO
    99 RETURN
    END SUBROUTINE SEARCH
