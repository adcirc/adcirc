!--------------------------------------------------------------
! Global IO module.

!  This module exists to write out global output files on
!  parallel machines and one file on uniproc machines.
!--------------------------------------------------------------

    module global_io
    use SIZES
    use VERSION
    use GLOBAL
    use MESH, ONLY : NP, AGRID
#ifdef CMPI
#ifdef HAVE_MPI_MOD
    use mpi
#endif
#endif
    contains

!--------------------------------------------------------------------
!                    S U B R O U T I N E
!     A L L O C A T E   F U L L   D O M A I N   I O   A R R A Y S
!--------------------------------------------------------------------
!     jgf49.44: Allocates memory for the full domain arrays for i/o
!     purposes; these arrays are both read from and written to hotstart
!     files. Arrays that are only written are allocated in the
!     subroutine that does the writing.

!     jgf51.46: Just to clarify, these arrays are needed during
!     hotstart initialization, to read in the previous state of the
!     fulldomain simulation.a So, they need to be allocated prior
!     to hotstart initialization. These arrays may also be needed
!     to write fulldomain output, but care should be taken so they
!     are not allocated more than once, i.e., in write_output.F
!     or global.F.

!--------------------------------------------------------------------
    SUBROUTINE allocateFullDomainIOArrays()
    IMPLICIT NONE

    call setMessageSource("allocateFullDomainIOArrays")
#if defined(GLOBAL_TRACE) || defined(ALL_TRACE)
    call allMessage(DEBUG,"Enter.")
#endif
    ALLOCATE(ETA1_g(NP_G))
    ALLOCATE(ETA2_g(NP_G))
    ALLOCATE(UU2_g(NP_G))
    ALLOCATE(VV2_g(NP_G))
    IF (IM == 10) THEN
        ALLOCATE(CH1_g(NP_G))
    ENDIF
    ALLOCATE(EtaDisc_g(NP_G))
    ALLOCATE(NodeCode_g(NP_G))
    ALLOCATE(NOFF_g(NE_G))
    ALLOCATE(NNodeCode_g(NP_G))

#if defined(GLOBAL_TRACE) || defined(ALL_TRACE)
    call allMessage(DEBUG,"Return.")
#endif
    call unsetMessageSource()
!--------------------------------------------------------------------
    END SUBROUTINE allocateFullDomainIOArrays
!--------------------------------------------------------------------

!--------------------------------------------------------------
!                  S U B R O U T I N E
!     C O L L E C T  F U L L  D O M A I N  A R R A Y
!--------------------------------------------------------------
! jgf48.03 Collects array data from each subdomain.
!--------------------------------------------------------------
    subroutine collectFullDomainArray(descript, pack_cmd, unpack_cmd)
    USE SIZES
    USE GLOBAL
    implicit none
#ifdef CMPI
#ifndef HAVE_MPI_MOD
    include 'mpif.h'
#endif
#endif
    type (OutputDataDescript_t) :: descript
    external pack_cmd
    external unpack_cmd
#ifdef CMPI
! the subroutine used to write the file
    integer :: ierr, status(MPI_STATUS_SIZE), request
    integer, save:: tagbase = 6000
    integer :: iproc
    integer :: bufsize
    integer :: ibucket
    integer :: iremainder ! after dividing bufsize by array rank
    integer :: istart     ! vector tuple to start with
    integer :: iend       ! vector tuple to end on
    integer :: tag
! number of vector tuples in the buffer
    integer :: num
    integer :: i, j, k

    call setMessageSource("collectFullDomainArray")
#if defined(GLOBALIO_TRACE) || defined(ALL_TRACE)
    call allMessage(DEBUG,"Enter.")
#endif
    bufsize = min(BUFSIZE_MAX, &
    descript % num_items_per_record * descript % num_fd_records)
!     num will be less than the number of full domain records if the
!     buffer is too small to hold all the records in the full domain,
!     in this case it is the number of records passed back to proc 0
!     on each iteration of the while loop below

! jgf51.50: What if the bufsize is not evenly divisible by the
! number of items per record? Need to check the remainder.
    iremainder = modulo(bufsize, descript % num_items_per_record)
    num = ( bufsize - iremainder ) / descript % num_items_per_record

    iend    = num
    istart  = 1

    if (tagbase == 5000) then
        tagbase = 6000
    else
        tagbase = 5000
    endif
    ibucket = 0

    do while (istart <= iend)

    !------------------------------------------------------------
    ! Initialize
    !------------------------------------------------------------
        if ( descript % isInteger .eqv. .TRUE. ) then
            integerBuffer(:)  = int(descript % initial_value)
        else
            buf(:)  = descript % initial_value
        endif
        ibucket = ibucket + 1
        tag     = tagbase + mod(ibucket, 8)

    !        now pack the buffer
        call pack_cmd(descript, istart, iend)
    !        now send data to processor 0
        if ( descript % isInteger .eqv. .TRUE. ) then
            call mpi_reduce(integerBuffer, integerResultBuffer, bufsize, &
            MPI_INTEGER, MPI_SUM, 0, COMM, ierr)
        else
            call mpi_reduce(buf, resultBuf, bufsize, float_type, MPI_SUM, &
            &                      0, COMM, ierr)
        endif
        if (myproc == 0) then
            call unpack_cmd(descript, istart, iend)
        end if
    !        set new starting position to just after the
    !        current ending position in full domain array
        istart = iend + 1
    !        set new ending position to either the current start plus the
    !        number of records that will fit in the buffer (minus 1),
    !        or to the end of the full domain array, whichever is less
        iend   = min(istart + num - 1, descript % num_fd_records)
        num    = iend - istart + 1
    end do
#endif
!! CMPI

    1000 format(2x, i8, 2x, 1pE20.10E3, 1pE20.10E3, 1pE20.10E3, 1pE20.10E3)
    1100 FORMAT(2x,1pE20.10E3,5X,I10)
#if defined(GLOBALIO_TRACE) || defined(ALL_TRACE)
    call allMessage(DEBUG,"Return.")
#endif
    call unsetMessageSource()
!--------------------------------------------------------------
    end subroutine collectFullDomainArray
!--------------------------------------------------------------

!--------------------------------------------------------------
! S U B R O U T I N E   P A C K  O N E
!--------------------------------------------------------------
!  jgf48.03 Subroutine to store a single array of real numbers
!  to a buffer
!--------------------------------------------------------------
    subroutine packOne(descript, istart, iend)
    USE SIZES
    USE GLOBAL
    implicit none

    type (OutputDataDescript_t) :: descript
    integer :: i, j, istart, iend, iglobal
    integer :: ioffset

    call setMessageSource("packOne")
#ifdef GLOBALIO_TRACE
    call allMessage(DEBUG,"Enter")
#endif

! jgf51.21.24: Updated and generalized to take into account wet/dry
! if needed
#ifdef CMPI
    ioffset = istart - 1
    if ( descript % isInteger .eqv. .TRUE. ) then
              
        do i = 1, descript % num_records_this
            iglobal = descript % imap(i)
            if (istart <= iglobal .AND. iglobal <= iend) then
                integerBuffer(iglobal-ioffset) = descript % iarray(i)
            end if
        end do

    else

        do i = 1, descript % num_records_this
            iglobal = descript % imap(i)
            if (istart <= iglobal .AND. iglobal <= iend) then
                buf(iglobal - ioffset ) = descript % array(i)
            ! jgf51.21.24: Updated and generalized to take into account wet/dry
            ! jgf52.25: Station data that should take wet dry state
            ! into account have already done so in subroutine stationArrayInterp()
            ! in module write_output.F. For stations, it doesn't make
            ! sense to check the nodecode.
                if ( descript % considerWetDry.eqv. .TRUE. ) then
                    if ( descript % isStation.eqv. .FALSE. ) then
                        if ( nodecode(i) == 0 ) then
                            buf(iglobal-ioffset) = descript % alternate_value
                        endif
                    endif
                endif
            endif
        end do

    endif
#endif

#ifdef GLOBALIO_TRACE
    call allMessage(DEBUG,"Return")
#endif
    call unsetMessageSource()

    return
!--------------------------------------------------------------
    end subroutine packOne
!--------------------------------------------------------------

!--------------------------------------------------------------
! S U B R O U T I N E   U N P A C K  O N E
!--------------------------------------------------------------
!  Subroutine to retrieve a single array of real numbers
!  from a buffer
!--------------------------------------------------------------
    subroutine unpackOne(descript, istart, iend)
    USE SIZES
    USE GLOBAL
    implicit none

    type (OutputDataDescript_t) :: descript
    integer :: i, j, istart, iend, iglobal
    integer :: ioffset
          
    call setMessageSource("unpackOne")
#ifdef GLOBALIO_TRACE
    call allMessage(DEBUG,"Enter")
#endif

    j = 1

    if ( descript % isInteger .eqv. .TRUE. ) then

        do i = istart, iend
            descript % iarray_g(i) = integerResultBuffer(j)
            j = j + 1
        end do
             
    else

        do i = istart, iend
            descript % array_g(i) = resultBuf(j)
            j = j + 1
        end do

    endif

#ifdef GLOBALIO_TRACE
    call allMessage(DEBUG,"Return")
#endif
    call unsetMessageSource()

!--------------------------------------------------------------
    end subroutine unpackOne
!--------------------------------------------------------------

!--------------------------------------------------------------
! S U B R O U T I N E   P A C K  T W O
!--------------------------------------------------------------
! Subroutine to pack two interleaved arrays of real
! numbers into a buffer
!--------------------------------------------------------------
    subroutine packTwo(descript, istart, iend)
    USE SIZES
    USE GLOBAL
    implicit none

    type (OutputDataDescript_t) :: descript
    integer :: i, istart, iend, iglobal
    integer :: ioffset, j
          
    call setMessageSource("packTwo")
#ifdef GLOBALIO_TRACE
    call allMessage(DEBUG,"Enter")
#endif

    ioffset = istart - 1
    do i = 1, descript % num_records_this
        iglobal = descript % imap(i)
        if (istart <= iglobal .AND. iglobal <= iend) then
            j = 2*(iglobal - ioffset) - 1
            buf(j)     = descript % array(i)
            buf(j + 1) = descript % array2(i)
        end if
    end do

#ifdef GLOBALIO_TRACE
    call allMessage(DEBUG,"Return")
#endif
    call unsetMessageSource()

    return
    1000 format(2x, i8, 2x, 1pE20.10E3, 1pE20.10E3)
!--------------------------------------------------------------
    end subroutine packTwo
!--------------------------------------------------------------

!--------------------------------------------------------------
! S U B R O U T I N E  U N P A C K  T W O
!--------------------------------------------------------------
! Subroutine to unpack two interleaved arrays of real
! numbers into a buffer
!--------------------------------------------------------------
    subroutine unpackTwo(descript, istart, iend)
    USE SIZES
    USE GLOBAL
    implicit none

    type (OutputDataDescript_t) :: descript
    integer :: i, j, istart, iend
          
    call setMessageSource("unpackTwo")
#ifdef GLOBALIO_TRACE
    call allMessage(DEBUG,"Enter")
#endif

    j = 1
    do i = istart, iend
        descript % array_g(i) = resultBuf(j)
        descript % array2_g(i) = resultBuf(j+1)
        j = j + 2
    end do

#ifdef GLOBALIO_TRACE
    call allMessage(DEBUG,"Return")
#endif
    call unsetMessageSource()
          
    return
!--------------------------------------------------------------
    end subroutine unpackTwo
!--------------------------------------------------------------

!--------------------------------------------------------------
! S U B R O U T I N E   P A C K  M  B Y  N P
!--------------------------------------------------------------
! Subroutine to pack an m x np array of real
! numbers into a buffer
!--------------------------------------------------------------
    subroutine packMbyNP(descript, istart, iend)
    USE SIZES
    USE GLOBAL
    implicit none

    type (OutputDataDescript_t) :: descript
    integer :: i, istart, iend, iglobal
    integer :: ioffset, j
    integer :: k ! frequency counter

    call setMessageSource("packMbyNP")
#if defined(GLOBALIO_TRACE) || defined(ALL_TRACE)
    call allMessage(DEBUG,"Enter.")
#endif
    ioffset = istart - 1
    do i = 1, descript % num_records_this
        iglobal = descript % imap(i)
        if (istart <= iglobal .AND. iglobal <= iend) then
            j = descript%num_items_per_record * (iglobal-ioffset) &
            - (descript%num_items_per_record - 1 )
            do k = 0, ( descript % num_items_per_record - 1 )
                buf(j+k) = descript % array2D(k+1,i)
            end do
        end if
    end do

    1000 format(2x, i8, 2x, 1pE20.10E3, 1pE20.10E3)
#if defined(GLOBALIO_TRACE) || defined(ALL_TRACE)
    call allMessage(DEBUG,"Return.")
#endif
    call unsetMessageSource()
    return
!--------------------------------------------------------------
    end subroutine packMbyNP
!--------------------------------------------------------------

!--------------------------------------------------------------
! S U B R O U T I N E  U N P A C K  M  B Y  N P
!--------------------------------------------------------------
! Subroutine to unpack an m x np array of real
! numbers out of a buffer
!--------------------------------------------------------------
    subroutine unpackMbyNP(descript, istart, iend)
    USE SIZES
    USE GLOBAL
    implicit none

    type (OutputDataDescript_t) :: descript
    integer :: i, j, istart, iend
    integer :: k ! frequency counter

    call setMessageSource("unpackMbyNP")
#if defined(GLOBALIO_TRACE) || defined(ALL_TRACE)
    call allMessage(DEBUG,"Enter.")
#endif
    j = 1
    do i = istart, iend
        do k = 1, descript % num_items_per_record
            descript % array2D_g(k,i) = resultBuf(j)
            j = j + 1
        end do
    end do
#if defined(GLOBALIO_TRACE) || defined(ALL_TRACE)
    call allMessage(DEBUG,"Return.")
#endif
    call unsetMessageSource()
    return
!--------------------------------------------------------------
    end subroutine unpackMbyNP
!--------------------------------------------------------------

!--------------------------------------------------------------
! S U B R O U T I N E   P A C K  N P  B Y  M
!--------------------------------------------------------------
! Subroutine to pack an np x m array of real
! numbers into a buffer
!--------------------------------------------------------------
    subroutine packNPbyM(descript, istart, iend)
    USE SIZES
    USE GLOBAL
    implicit none

    type (OutputDataDescript_t) :: descript
    integer :: i, istart, iend, iglobal
    integer :: ioffset, j
    integer :: k ! frequency counter

    call setMessageSource("packNPbyM")
#if defined(GLOBALIO_TRACE) || defined(ALL_TRACE)
    call allMessage(DEBUG,"Enter.")
#endif
    ioffset = istart - 1
    do i = 1, descript % num_records_this
        iglobal = descript % imap(i)
        if (istart <= iglobal .AND. iglobal <= iend) then
            j = descript%num_items_per_record * (iglobal-ioffset) &
            - (descript%num_items_per_record - 1 )
            do k = 0, ( descript % num_items_per_record - 1 )
                buf(j+k) = descript % array2D(i,k+1)
            end do
        end if
    end do

    1000 format(2x, i8, 2x, 1pE20.10E3, 1pE20.10E3)
#if defined(GLOBALIO_TRACE) || defined(ALL_TRACE)
    call allMessage(DEBUG,"Return.")
#endif
    call unsetMessageSource()
    return
!--------------------------------------------------------------
    end subroutine packNPbyM
!--------------------------------------------------------------

!--------------------------------------------------------------
! S U B R O U T I N E  U N P A C K   N P  B Y  M
!--------------------------------------------------------------
! Subroutine to unpack an np x m array of real
! numbers out of a buffer
!--------------------------------------------------------------
    subroutine unpackNPbyM(descript, istart, iend)
    USE SIZES
    USE GLOBAL
    implicit none

    type (OutputDataDescript_t) :: descript
    integer :: i, j, istart, iend
    integer :: k ! frequency counter

    call setMessageSource("unpackNPbyM")
#if defined(GLOBALIO_TRACE) || defined(ALL_TRACE)
    call allMessage(DEBUG,"Enter.")
#endif
    j = 1
    do i = istart, iend
        do k = 1, descript % num_items_per_record
            descript % array2D_g(i,k) = resultBuf(j)
            j = j + 1
        end do
    end do
#if defined(GLOBALIO_TRACE) || defined(ALL_TRACE)
    call allMessage(DEBUG,"Return.")
#endif
    call unsetMessageSource()
    return
!--------------------------------------------------------------
    end subroutine unpackNPbyM
!--------------------------------------------------------------

!--------------------------------------------------------------
!    S U B R O U T I N E   O P E N _ G B L _ F I L E
!--------------------------------------------------------------
! Open Global File: opens the file, opens the write_header
!                   routine and closes the file
!--------------------------------------------------------------
    subroutine open_gbl_file(lun, filename, size_g, size_this, &
    write_header)
    USE SIZES
    USE GLOBAL
    implicit none

    external write_header ! subroutine used to actually write the header
    integer :: lun, size_this, size_g, szz
    character(*) :: filename

    call setMessageSource("open_gbl_file")
#ifdef GLOBALIO_TRACE
    call allMessage(DEBUG,"Enter")
#endif

    szz = size_g
    if (mnproc == 1 .OR. WRITE_LOCAL_FILES) szz = size_this

    if (myproc == 0 .OR. WRITE_LOCAL_FILES) then
        open(lun, file=trim(filename), status='UNKNOWN')
        call write_header(lun,szz)
        close(lun)
    end if

#ifdef GLOBALIO_TRACE
    call allMessage(DEBUG,"Return")
#endif
    call unsetMessageSource()

    return
!--------------------------------------------------------------
    end subroutine open_gbl_file
!--------------------------------------------------------------

!--------------------------------------------------------------
!    S U B R O U T I N E   O P E N _ M I N M A X _ F I L E
!--------------------------------------------------------------
! Open Global File: opens the file, replacing the existing file,
!                   executes the write_header routine and closes
!                   the file.
!--------------------------------------------------------------
    subroutine open_minmax_file(lun, filename, size_g, size_this, &
    nrecs_this,write_header)
    USE SIZES
    USE GLOBAL
    implicit none

    external write_header ! subroutine used to actually write the header
    integer :: lun, size_this, size_g, szz
    integer :: nrecs_this  !tcm v51.20.06
    character(*) :: filename

    call setMessageSource("open_minmax_file")
#ifdef GLOBALIO_TRACE
    call allMessage(DEBUG,"Enter")
#endif

    szz = size_g
    if (mnproc == 1 .OR. WRITE_LOCAL_FILES) szz = size_this

    if (myproc == 0 .OR. WRITE_LOCAL_FILES) then
        open(lun, file=trim(filename), status='REPLACE')
        call write_header(lun,szz,nrecs_this)
        close(lun)
    end if

#ifdef GLOBALIO_TRACE
    call allMessage(DEBUG,"Return")
#endif
    call unsetMessageSource()

    return
!--------------------------------------------------------------
    end subroutine open_minmax_file
!--------------------------------------------------------------


!--------------------------------------------------------------
!      S U B R O U T I N E  W R I T E   S P A R S E
!--------------------------------------------------------------
! jgf51.21.24: Writes sparse ascii format.
!--------------------------------------------------------------
    subroutine writeSparse(descript, TimeLoc, it, write_cmd)
    USE SIZES
    USE GLOBAL
    implicit none
    type (OutputDataDescript_t) :: descript
    real(8), intent(in) :: TimeLoc
    integer, intent(in) :: it
    external write_cmd
#ifdef CMPI
#ifndef HAVE_MPI_MOD
    include 'mpif.h'
#endif
    integer :: ierr, status(MPI_STATUS_SIZE), request
    integer :: nLWetNodes, nGWetNodes
    integer :: iglobal
#endif
    integer :: num, i, j, k
    integer, save:: tagbase = 6000
    integer :: iproc
    integer :: bufsize, ibucket
    integer :: istart, iend, tag

    call setMessageSource("writeSparse")
#ifdef GLOBALIO_TRACE
    call allMessage(DEBUG,"Enter")
#endif

! serial or writing local files
    if ((mnproc == 1) .OR. (WRITE_LOCAL_FILES)) then
        open(descript%lun, file=trim(descript%file_name), &
        access='SEQUENTIAL', position='APPEND')
        write(descript%lun, 1100) TimeLoc, it
        call write_cmd(descript % lun, descript, 1, descript % num_records_this)
        close(descript % lun)
#ifdef GLOBALIO_TRACE
        call allMessage(DEBUG,"Return")
#endif
        call unsetMessageSource()
        return
    else
#ifdef CMPI
    ! Count the number of wet nodes
        nLWetNodes = 0
        do i=1,np
            iglobal = descript%imap(i)
            if(iglobal <= 0) cycle ! cycle if node i is ghost
            if(nodecode(i) == 0) cycle ! cycle if node i is dry
            nLWetNodes=nLWetNodes+1
        enddo
        call mpi_reduce(nLWetNodes, nGWetNodes, 1, MPI_INTEGER, &
        MPI_SUM, 0, comm, ierr)
           
        if (myproc == 0) then
            open(descript%lun, file=trim(descript%file_name), &
            access='SEQUENTIAL', position='APPEND')
            write(descript%lun, 1101) TimeLoc, it, nGWetNodes, descript%alternate_value
        endif
           
        bufsize = min(BUFSIZE_MAX, &
        descript % num_items_per_record * descript % num_fd_records)
        num     = bufsize / descript % num_items_per_record
        iend    = num
        istart  = 1
           
        if (tagbase == 5000) then
            tagbase = 6000
        else
            tagbase = 5000
        endif
        ibucket = 0
           
        do while (istart < iend)
               
        !------------------------------------------------------------
        ! Initialize
        !------------------------------------------------------------
            buf(:)  = descript % initial_value
            ibucket = ibucket + 1
            tag     = tagbase + mod(ibucket, 8)
               
            call write_cmd(descript%lun, descript, istart, iend)
            call mpi_reduce(buf, resultBuf, bufsize, float_type, MPI_SUM, 0, &
            COMM, ierr)
            if (myproc == 0) then
                do i = istart, iend
                    j = 1 + (i-istart)*descript % num_items_per_record
                       
                ! f values are eqaul to the default value, skip this node
                    if(resultBuf(j) == descript % alternate_value) cycle
                       
                    write(descript % lun, 1000) i, (resultBuf(k), k = j, j + &
                    descript % num_items_per_record - 1)
                end do
            end if
               
            istart = iend + 1
            iend   = min(istart + num - 1, descript % num_fd_records)
            num    = iend - istart + 1
        end do
        if (myproc == 0) then
            close(descript%lun)
        endif
#endif
    endif

#ifdef GLOBALIO_TRACE
    call allMessage(DEBUG,"Return")
#endif
    call unsetMessageSource()

    1000 format(2x, i8, 2x, 1pE20.10E3, 1pE20.10E3, 1pE20.10E3, 1pE20.10E3)
    1100 FORMAT(2x,1pE20.10E3,5X,I10)
    1101 FORMAT(2x,1pE20.10E3,5X,I10,5X,I10,5X,1pE20.10E3)
!--------------------------------------------------------------
    end subroutine writeSparse
!--------------------------------------------------------------

!--------------------------------------------------------------
! These are the store, header routines. For each file (fort.61, ...)
! that is being globalize, there is a pair of routines : header61 and
! store61 etc.  The header routine writes out the header once
! and the store routine copies the data (heights, velocities, etc)
! to the buffer in parallel mode or in serial mode it just write out
! the data to file.
!--------------------------------------------------------------


!--------------------------------------------------------------
! S U B R O U T I N E   S T O R E  O N E
!--------------------------------------------------------------
! jgf47.05: Subroutine to store a single array of real numbers
!   +to disk in text format if WRITE_LOCAL_FILES is .true.
!   +to a buffer if we are running in parallel
!--------------------------------------------------------------
    subroutine storeOne(lun, descript, istart, iend)
    USE SIZES
    USE GLOBAL
    implicit none

    type (OutputDataDescript_t) :: descript
    integer :: i, istart, iend, iglobal, lun
    integer :: ioffset

    if (WRITE_LOCAL_FILES) then
        do i = 1, descript % num_records_this
            write(lun , 1000) i, descript % array(i)
        end do
        return
    end if

#ifdef CMPI
    ioffset = istart - 1
    do i = 1, descript % num_records_this
        iglobal = descript % imap(i)
        if (istart <= iglobal .AND. iglobal <= iend) then
            buf(iglobal-ioffset) = descript % array(i)
        end if
    end do
#endif

    return
    1000 format(2x, i8, 2x, 1pE20.10E3)
!--------------------------------------------------------------
    end subroutine storeOne
!--------------------------------------------------------------


!--------------------------------------------------------------
! S U B R O U T I N E   S T O R E  T W O
!--------------------------------------------------------------
! jgf47.05: Subroutine to store two interleaved arrays of real
! numbers
!  +to disk in text format if WRITE_LOCAL_FILES is .true.
!  +to a buffer if we are running in parallel
!--------------------------------------------------------------
    subroutine storeTwo(lun, descript, istart, iend)
    USE SIZES
    USE GLOBAL
    implicit none

    type (OutputDataDescript_t) :: descript
    integer :: i, istart, iend, iglobal, lun
    integer :: ioffset, j

    if (WRITE_LOCAL_FILES) then
        do i = 1, descript % num_records_this
            write(lun , 1000) i, descript % array(i), &
            descript % array2(i)
        end do
        return
    end if

#ifdef CMPI
    ioffset = istart - 1
    do i = 1, descript % num_records_this
        iglobal = descript % imap(i)
        if (istart <= iglobal .AND. iglobal <= iend) then
            j = 2*(iglobal - ioffset) - 1
            buf(j)     = descript % array(i)
            buf(j + 1) = descript % array2(i)
        end if
    end do
#endif
    return
    1000 format(2x, i8, 2x, 1pE20.10E3, 1pE20.10E3)
!--------------------------------------------------------------
    end subroutine storeTwo
!--------------------------------------------------------------

!--------------------------------------------------------------
!     S U B R O U T I N E   H E A D E R 6 1
!--------------------------------------------------------------
! Elevation for Elevation Recording station: fort.61
!--------------------------------------------------------------
    subroutine header61(lun, size_this)
    USE SIZES
    USE GLOBAL
    implicit none
    integer :: lun, size_this

    write(lun, 1000) rundes, runid, agrid
    write(lun, 1010) ntrspe, size_this, dtdp*nspoole, nspoole, 1, &
    FileFmtVersion

    1000 FORMAT(1X,A32,2X,A24,2X,A24)
    1010 FORMAT(1X,I10,1X,I10,1X,E15.7E3,1X,I5,1X,I5,1X, &
    'FileFmtVersion: ',I10)
!--------------------------------------------------------------
    end subroutine header61
!--------------------------------------------------------------

!--------------------------------------------------------------
!    S U B R O U T I N E   H E A D E R 6 2
!--------------------------------------------------------------
! Velocity for Velocity Recording station: fort.62
!--------------------------------------------------------------
    subroutine header62(lun, size_this)
    USE SIZES
    USE GLOBAL
    implicit none
    integer :: lun, size_this

    write(lun, 1000) rundes, runid, agrid
    write(lun, 1010) ntrspv, size_this, dtdp*nspoolv, nspoolv, 2, &
    FileFmtVersion

    1000 FORMAT(1X,A32,2X,A24,2X,A24)
    1010 FORMAT(1X,I10,1X,I10,1X,E15.7E3,1X,I5,1X,I5,1X, &
    'FileFmtVersion: ',I10)
!--------------------------------------------------------------
    end subroutine header62
!--------------------------------------------------------------

!--------------------------------------------------------------
!    S U B R O U T I N E   H E A D E R 6 3
!--------------------------------------------------------------
! Elevation for all nodes: fort.63
!--------------------------------------------------------------
    subroutine header63(lun, size_this)
    USE SIZES
    USE GLOBAL
    implicit none
    integer :: lun, size_this

    write(lun, 1000) rundes, runid, agrid
    write(lun, 1010) ndsetse, size_this, dtdp*nspoolge, nspoolge, 1, &
    FileFmtVersion
    1000 FORMAT(1X,A32,2X,A24,2X,A24)
    1010 FORMAT(1X,I10,1X,I10,1X,E15.7E3,1X,I8,1X,I5,1X, &
    'FileFmtVersion: ',I10)
!--------------------------------------------------------------
    end subroutine header63
!--------------------------------------------------------------

!--------------------------------------------------------------
! S U B R O U T I N E   H E A D E R _ M A X
!--------------------------------------------------------------
! Maximum elevation for all nodes: fort.63
!--------------------------------------------------------------
    subroutine header_max(lun, size_this,nrecs_this)
    USE SIZES
    USE GLOBAL
    implicit none
    integer :: lun, size_this
    integer :: nrecs_this  !tcm v51.20.06

    write(lun, 1000) rundes, runid, agrid
! cm v51.20.06 Changed number of records from 1 to nrecs_this (1 or 2)
    write(lun, 1010) nrecs_this, size_this, 1.d0, 1, 1, FileFmtVersion

    1000 FORMAT(1X,A32,2X,A24,2X,A24)
    1010 FORMAT(1X,I10,1X,I10,1X,E15.7E3,1X,I8,1X,I5,1X, &
    'FileFmtVersion: ',I10)
!--------------------------------------------------------------
    end subroutine header_max
!--------------------------------------------------------------

!--------------------------------------------------------------
!  S U B R O U T I N E   H E A D E R 6 4
!--------------------------------------------------------------
! Velocity for all nodes: fort.64
!--------------------------------------------------------------
    subroutine header64(lun, size_this)
    USE SIZES
    USE GLOBAL
    implicit none
    integer :: lun, size_this

    write(lun, 1000) rundes, runid, agrid
    write(lun, 1010) ndsetsv, size_this, dtdp*nspoolgv, nspoolgv, 2, &
    FileFmtVersion

    1000 FORMAT(1X,A32,2X,A24,2X,A24)
    1010 FORMAT(1X,I10,1X,I10,1X,E15.7E3,1X,I8,1X,I5,1X, &
    'FileFmtVersion: ',I10)
!--------------------------------------------------------------
    end subroutine header64
!--------------------------------------------------------------

!--------------------------------------------------------------
! S U B R O U T I N E   H E A D E R 7 1
!--------------------------------------------------------------
! Pressure for Meteorological Recording station: fort.71
!--------------------------------------------------------------
    subroutine header71(lun, size_this)
    USE SIZES
    USE GLOBAL
    implicit none
    integer :: lun, size_this

    write(lun, 1000) rundes, runid, agrid
    write(lun, 1010) ntrspm, size_this, dtdp*nspoolm, nspoolm, 1, &
    FileFmtVersion

    1000 FORMAT(1X,A32,2X,A24,2X,A24)
    1010 FORMAT(1X,I10,1X,I10,1X,E15.7E3,1X,I8,1X,I5,1X, &
    'FileFmtVersion: ',I10)
!--------------------------------------------------------------
    end subroutine header71
!--------------------------------------------------------------

!--------------------------------------------------------------
! S U B R O U T I N E   H E A D E R 7 2
!--------------------------------------------------------------
! Wind Velocity for Meteorological Recording stations : fort.72
!--------------------------------------------------------------
    subroutine header72(lun, size_this)
    USE SIZES
    USE GLOBAL
    implicit none
    integer :: lun, size_this

    write(lun, 1000) rundes, runid, agrid
    write(lun, 1010) ntrspm, size_this, dtdp*nspoolm, nspoolm, 2, &
    FileFmtVersion

    1000 FORMAT(1X,A32,2X,A24,2X,A24)
    1010 FORMAT(1X,I10,1X,I10,1X,E15.7E3,1X,I8,1X,I5,1X, &
    'FileFmtVersion: ',I10)
!--------------------------------------------------------------
    end subroutine header72
!--------------------------------------------------------------

!--------------------------------------------------------------
! S U B R O U T I N E   H E A D E R 7 3
!--------------------------------------------------------------
! Atmospheric Pressure for all nodes: fort.73
!--------------------------------------------------------------
    subroutine header73(lun, size_this)
    USE SIZES
    USE GLOBAL
    implicit none
    integer :: lun, size_this

    write(lun, 1000) rundes, runid, agrid
    write(lun, 1010) ndsetsw, size_this, dtdp*nspoolgw, nspoolgw, 1, &
    FileFmtVersion

    1000 FORMAT(1X,A32,2X,A24,2X,A24)
    1010 FORMAT(1X,I10,1X,I10,1X,E15.7E3,1X,I8,1X,I5,1X, &
    'FileFmtVersion: ',I10)
!--------------------------------------------------------------
    end subroutine header73
!--------------------------------------------------------------

!--------------------------------------------------------------
! S U B R O U T I N E   H E A D E R 7 4
!--------------------------------------------------------------
! Wind Stress for all nodes: fort.74
!--------------------------------------------------------------
    subroutine header74(lun, size_this)
    USE SIZES
    USE GLOBAL
    implicit none
    integer :: lun, size_this

    write(lun, 1000) rundes, runid, agrid
    write(lun, 1010) ndsetsw, size_this, dtdp*nspoolgw, nspoolgw, 2, &
    FileFmtVersion

    1000 FORMAT(1X,A32,2X,A24,2X,A24)
    1010 FORMAT(1X,I10,1X,I10,1X,E15.7E3,1X,I8,1X,I5,1X, &
    'FileFmtVersion: ',I10)
!--------------------------------------------------------------
    end subroutine header74
!--------------------------------------------------------------

!--------------------------------------------------------------
!  S U B R O U T I N E   H E A D E R 7 7
!--------------------------------------------------------------
! Weir elevation change for all nodes: fort.77
!--------------------------------------------------------------
    subroutine header77(lun, size_this)
    USE SIZES
    USE GLOBAL
    implicit none
    integer :: lun, size_this

    write(lun, 1000) rundes, runid, agrid
    write(lun, 1010) ndsets_tvw, size_this, dtdp*nspool_tvw, &
    nspool_tvw, 1, FileFmtVersion

    1000 FORMAT(1X,A32,2X,A24,2X,A24)
    1010 FORMAT(1X,I10,1X,I10,1X,E15.7E3,1X,I8,1X,I5,1X, &
    'FileFmtVersion: ',I10)
!--------------------------------------------------------------
    end subroutine header77
!--------------------------------------------------------------

!--------------------------------------------------------------
! S U B R O U T I N E   H E A D E R 9 1
!--------------------------------------------------------------
! Ice Concentration for Meteorological Recording station: fort.91
! tcm v49.64.01 -- added
!--------------------------------------------------------------
    subroutine header91(lun, size_this)
    USE SIZES
    USE GLOBAL
    implicit none
    integer :: lun, size_this

    write(lun, 1000) rundes, runid, agrid
    write(lun, 1010) ntrspm, size_this, dtdp*nspoolm, nspoolm, 1, &
    FileFmtVersion

    1000 FORMAT(1X,A32,2X,A24,2X,A24)
    1010 FORMAT(1X,I10,1X,I10,1X,E15.7E3,1X,I8,1X,I5,1X, &
    'FileFmtVersion: ',I10)
!--------------------------------------------------------------
    end subroutine header91
!--------------------------------------------------------------

!--------------------------------------------------------------
! S U B R O U T I N E   H E A D E R 9 3
!--------------------------------------------------------------
! Ice Concentration Field for all nodes: fort.93
! tcm v49.64.01 -- added
!--------------------------------------------------------------
    subroutine header93(lun, size_this)
    USE SIZES
    USE GLOBAL
    implicit none
    integer :: lun, size_this

    write(lun, 1000) rundes, runid, agrid
    write(lun, 1010) ndsetsw, size_this, dtdp*nspoolgw, nspoolgw, 1, &
    FileFmtVersion

    1000 FORMAT(1X,A32,2X,A24,2X,A24)
    1010 FORMAT(1X,I10,1X,I10,1X,E15.7E3,1X,I8,1X,I5,1X, &
    'FileFmtVersion: ',I10)
!--------------------------------------------------------------
    end subroutine header93
!--------------------------------------------------------------


!--------------------------------------------------------------
! S U B R O U T I N E   H E A D E R 8 1
!--------------------------------------------------------------
! Concentration Recording station: fort.81
!--------------------------------------------------------------
    subroutine header81(lun, size_this)
    USE SIZES
    USE GLOBAL
    implicit none
    integer :: lun, size_this

    write(lun, 1000) rundes, runid, agrid
    write(lun, 1010) ntrspc, size_this, dtdp*nspoolc, nspoolc, 1, &
    FileFmtVersion

    1000 FORMAT(1X,A32,2X,A24,2X,A24)
    1010 FORMAT(1X,I10,1X,I10,1X,E15.7E3,1X,I8,1X,I5,1X, &
    'FileFmtVersion: ',I10)
!--------------------------------------------------------------
    end subroutine header81
!--------------------------------------------------------------

!--------------------------------------------------------------
! S U B R O U T I N E
!    W R I T E  S T A T I O N  H E A D E R
!--------------------------------------------------------------
! jgf47.05: This subroutine will write the header for station
! files (scalars or vectors, 2D or 3D). This is intended to
! eventually replace the header subroutines "headerXX" for
! station files.
!--------------------------------------------------------------
    subroutine writeStationHeader(lun, numSta, typeStr)
    USE SIZES
    USE GLOBAL
    use global_3dvs, only: &
    ndset3dsv, nspo3dsv, nfen, &
    ndset3dst, nspo3dst, &
    ndset3dsd, nspo3dsd
    implicit none
    integer :: lun               ! logical unit number to write to
    integer :: numSta            ! number of stations to write
    character(len=10) typeStr ! the type of header to write

    write(lun, 1000) rundes, runid, agrid

    select case(trim(typeStr))
    case("Elev")
    write(lun, 1010) ntrspe, numSta, dtdp*nspoole, nspoole, 1, &
    FileFmtVersion
    case("Vel2D")
    write(lun, 1010) ntrspv, numSta, dtdp*nspoolv, nspoolv, 2, &
    FileFmtVersion
    case("Vel3D")
    write(lun, 1020) ndset3dsv, numSta, dtdp*nspo3dsv, &
    nspo3dsv, nfen, 3, FileFmtVersion
    case("Turb3D")
    write(lun, 1020) ndset3dst, numSta, dtdp*nspo3dst, &
    nspo3dst, nfen, 3, FileFmtVersion
    case("Dens2D")
    write(ScreenUnit,*) &
    'ERROR: 2D density station output not implemented.'
    stop
    case("Dens3D")
    write(lun, 1020) ndset3dsd, numSta, dtdp*nspo3dsd, &
    nspo3dsd, nfen, 3, FileFmtVersion
    case("Press","Wind")
    write(lun, 1010) ntrspm, numSta, dtdp*nspoolm, nspoolm, 1, &
    FileFmtVersion
    case("Conc2D")
    write(lun, 1010) ntrspc, numSta, dtdp*nspoolc, nspoolc, 1, &
    FileFmtVersion
    case("Conc3D")
    write(ScreenUnit,*) &
    'ERROR: 3D conc. station output not implemented.'
    stop
    case default
    write(ScreenUnit,*) &
    'ERROR: Station header type unrecongnized.'
    stop
    end select

    1000 FORMAT(1X,A32,2X,A24,2X,A24)
    1010 FORMAT(1X,I10,1X,I10,1X,E15.7E3,1X,I5,1X,I5,1X, &
    'FileFmtVersion: ',I10)
    1020 FORMAT(1X,I10,1X,I10,1X,E15.7E3,1X,I5,1X,I5,1X,I5,1X, &
    'FileFmtVersion: ',I10)
!--------------------------------------------------------------
    end subroutine writeStationHeader
!--------------------------------------------------------------

!--------------------------------------------------------------
! S U B R O U T I N E
!    W R I T E  D O M A I N  H E A D E R
!--------------------------------------------------------------
! jgf47.05: This subroutine will write the header for domain
! output files, i.e., not station files. It handles scalars or
! vectors, 2D or 3D). This is intended to eventually replace
! the header subroutines "headerXX" for domain files.
!--------------------------------------------------------------
    subroutine writeDomainHeader(lun, filename, numNodes_g, &
    numNodes, typeStr)
    USE SIZES
    USE GLOBAL
    use global_3dvs, only: &
    ndset3dgv, nspo3dgv, nfen, &
    ndset3dgt, nspo3dgt, &
    ndset3dgd, nspo3dgd
    implicit none
    integer :: lun               ! logical unit number to write to
    character(*) filename     ! name of file to create
    integer :: numNodes          ! number of nodes in this domain
    integer :: numNodes_g        ! number of nodes in the full domain
    character(len=10) typeStr ! the type of header to write
    integer :: nodes             ! number of nodes to write into header

!     Unless we are processor 0 or we are supposed to write local
!     files, there is nothing to do but *** RETURN EARLY ***
    if ( (myproc /= 0) .AND. ( .NOT. WRITE_LOCAL_FILES) ) return

!     Set the appropriate number of nodes
    if ( (myproc == 1) .OR. (WRITE_LOCAL_FILES) ) then
        nodes = numNodes
    else
        nodes = numNodes_g
    endif

!     Open the file
    open(lun, file=filename, status='UNKNOWN')
    write(lun, 1000) rundes, runid, agrid

    select case(trim(typeStr))
    case("Elev")
    write(lun, 1010) ndsetse, nodes, dtdp*nspoolge, &
    nspoolge, 1, FileFmtVersion
    case("ElevMax")
    write(lun, 1010) 1, numNodes, 1.d0, 1, 1, FileFmtVersion
    case("Vel2D")
    write(lun, 1010) ndsetsv, nodes, dtdp*nspoolgv, &
    nspoolgv, 2, FileFmtVersion
    case("Vel3D")
    write(lun, 1020) ndset3dgv, nodes, dtdp*nspo3dgv, &
    nspo3dgv, nfen, 3, FileFmtVersion
    case("Turb3D")
    write(lun, 1020) ndset3dgt, nodes, dtdp*nspo3dgt, &
    nspo3dgt, nfen, 3, FileFmtVersion
    case("Dens2D")
    write(ScreenUnit,*) &
    'ERROR: 2D density output not implemented.'
    stop
    case("Dens3D")
    write(lun, 1020) ndset3dgd, nodes, dtdp*nspo3dgd, &
    nspo3dgd, nfen, 3, FileFmtVersion
    case("Press","Wind")
    write(lun, 1010) ndsetsw, nodes, dtdp*nspoolgw, &
    nspoolgw, 1, FileFmtVersion
    case("Conc2D")
    write(ScreenUnit,*) &
    'ERROR: 2D conc. output not implemented.'
    stop
    case("Conc3D")
    write(ScreenUnit,*) &
    'ERROR: 3D conc. output not implemented.'
    stop
    case("Tau0")
    write(lun, 1010) ndsetse, nodes, dtdp*nspoolge, &
    nspoolge, 1, FileFmtVersion
    case("sponge")
    write(lun, 1010) 1, nodes, dtdp*nspoolge, &
    nspoolge, 1, FileFmtVersion
    case("noff")
    write(lun, 1010) 1, nodes, dtdp*nspoolge, &
    nspoolge, 1, FileFmtVersion
    case("nodecode")
    write(lun, 1010) 1, nodes, dtdp*nspoolge, &
    nspoolge, 1, FileFmtVersion
    case("initDry")
    write(lun, 1010) 1, nodes, 0.d0, 0, 1, FileFmtVersion
    case default
    write(ScreenUnit,*) &
    'ERROR: Full domain header type unrecongnized.'
    end select

!     close the file
    close(lun)

    1000 FORMAT(1X,A32,2X,A24,2X,A24)
    1010 FORMAT(1X,I10,1X,I10,1X,E15.7E3,1X,I8,1X,I5,1X, &
    'FileFmtVersion: ',I10)
    1020 FORMAT(1X,I10,1X,I10,1X,E15.7E3,1X,I8,1X,I5,1X,I5,1X, &
    'FileFmtVersion: ',I10)
!--------------------------------------------------------------
    end subroutine writeDomainHeader
!--------------------------------------------------------------

!----------------------------------------------------------------------
!       S U B R O U T I N E   R E A D  M I N  M A X
!----------------------------------------------------------------------

!     jgf48.4636 Subroutine to read in continuous min and max files,
!     if they are present.  ASCII Min/Max file are NOT stored
!     in compact format.

!----------------------------------------------------------------------
    subroutine readMinMax(descript, timeloc)
    IMPLICIT NONE
    type(OutputDataDescript_t), intent(inout) :: descript
    real(8), intent(in) :: timeloc  ! adcirc time in seconds
    integer :: node                 ! node number of the min/max data
    character(len=80) :: skipline  ! dummy variable for min/max header data
    integer :: rawNode              ! node number, as read from file
    real(sz) :: rawDatum            ! array member value at node, as read from file
    integer :: irawDatum            ! array member value at node, as read from file
    integer :: numLinesInMinMaxFile ! count the lines to report to log file
    logical :: tooFewMinMaxLines    ! true if couldn't read enough lines from file
    integer :: ErrorIO              ! zero if file opened successfully
    integer :: i
    integer :: ndsetmax,size_this,nspoolmax,irtype,ffv
    real(sz) :: time_this
    character(20) :: dmstr
    integer, pointer :: idata(:)
    real(sz), pointer :: rdata(:)
    real(8) :: TimeMM ! timestamp of the min/max data in seconds since cold start
    integer :: ITMM ! time step of the min/max data in seconds since cold start

    call setMessageSource("readMinMax")
#if defined(GLOBALIO_TRACE) || defined(ALL_TRACE)
    call allMessage(DEBUG,"Enter.")
#endif

! Process Header Lines
    read(descript%lun,*,end=3990,err=3990) skipline   ! 1st header line
! cm v51.20.01 added specific reading of 2nd header line
    read(descript%lun,*,end=3990,err=3990) ndsetmax,size_this, &
    time_this,nspoolmax,irtype,dmstr,ffv

! jgf52.08.20: Read time and timestep and reject min/max data that correspond
! to a future time. This can happen when an analyst hotstarts a run,
! allows it to complete, then makes some adjustments to the input and
! then tries to re-run it while forgetting to remove or replace the
! min/max file from the previous attempt.

! It is hard to imagine a scenario where someone would want to keep
! the min/max record from the previous attempt under these circumstances.
! As a result, I am logging it as an error but allowing the run to
! continue if non-fatal override is enabled, since it would be
! annoying to have ADCIRC bomb out every time the analyst mistakenly
! leaves a min/max file in place.
    read(descript%lun,*,end=3990,err=3990) TimeMM, ITMM   ! TIME and IT line
    if (TimeMM > TimeLoc) then
        call allMessage(ERROR,'Max/min file '//trim(descript % file_name)// &
        ' contains data written after the hotstart time. '// &
        ' It may have been produced using different input parameters, '// &
        ' perhaps during a previously attempted hot start run. '// &
        ' Its values will not be read.')
        if (nfover == 0) then
            call allMessage(ERROR, &
            'Execution terminated due to invalid '// &
            trim(descript % file_name)//' file.')
            call globalioTerminate()
        else
            call allMessage(INFO,'The record for '// &
            trim(descript%file_name)// &
            ' will be started anew and exection will continue.')
#if defined(GLOBALIO_TRACE) || defined(ALL_TRACE)
            call allMessage(DEBUG,"Return.")
#endif
            call unsetMessageSource()
            CLOSE(descript%lun)  !close the max/min file
            return ! EARLY RETURN
        endif
    endif

! The file exists, it is open, and it doesn't correspond to a future
! time period, so read the data.
    numLinesInMinMaxFile = 0
! set the number of records we expect to read as well as the array to
! read data into
    rdata => descript % array
    idata => descript % iarray
    if (mnproc > 1) then
        rdata => descript % array_g
        idata => descript % iarray_g
    endif


    do I=1, descript % num_fd_records
        if (descript % isInteger.eqv. .TRUE. ) then
            read(descript%lun,*,end=3990,err=3990) rawNode, irawDatum !integer
        else
            read(descript%lun,*,end=3990,err=3990) rawNode, rawDatum  !float
        endif
        if ((rawNode >= 1) .AND. (rawNode <= descript%num_fd_records)) then
            node = rawNode
            if (descript % isInteger.eqv. .TRUE. ) then
                idata(node) = irawDatum       ! integer
            else
                rdata(node) = rawDatum         ! float
            endif
        else
            exit ! jump out of loop if node number is out of bounds
        endif
        numLinesInMinMaxFile = numLinesInMinMaxFile + 1
    enddo

! If this max/min file has two time records then the second
! record contains the time stamp (sec) relative to cold start
! at which the max/min was recorded
    if ((ndsetmax > 1) .AND. &
    (descript % minmax_timestamp.eqv. .TRUE. )) then
    ! In file and asking for them, set the arrays to read data into
        rdata => descript % array2
        if (mnproc > 1) then
            rdata => descript % array2_g
        endif
        read(descript%lun,*,end=3990,err=3990) skipline   ! TIME and IT line
        call logMessage(INFO, &
        'Max/min timestamps were found in '//trim(descript%file_name)// &
        ' and will be loaded and used.')
        do i=1, descript % num_fd_records
            read(descript%lun,*,end=3990,err=3990) rawNode, rawDatum
            if ((rawNode >= 1) .AND. (rawNode <= descript%num_fd_records)) then
                node = rawNode
                rdata(node) = rawDatum
            else
                exit ! jump out of loop if node number is out of bounds
            endif
        enddo
    endif

! time stamps not found in file but asking for them anyway
    if ( (ndsetmax == 1) .AND. &
    (descript % minmax_timestamp.eqv. .TRUE. ) ) then
        call logMessage(WARNING,'Max/min time stamps not present in '// &
        trim(descript % file_name)// &
        '. Max/min time stamps will be set to -99999.d0 to initalize.')
    endif
! time stamps are found in file but not asking for them
    if ( (ndsetmax > 1) .AND. &
    (descript % minmax_timestamp.eqv. .FALSE. ) ) then
        call logMessage(INFO,'Max/min timestamps present in "'// &
        trim(descript % file_name)//' but not needed. ')
    endif

    3990 CONTINUE ! jump to here if end of file is reached
    WRITE(scratchMessage,450) numLinesInMinMaxFile, &
    trim(descript % file_name)
    CALL logMessage(INFO,scratchMessage)
    IF (numLinesInMinMaxFile < (descript % num_fd_records)) THEN
        call allMessage(ERROR,'Not enough data in "' &
        //trim(descript % file_name)//'".')
    ENDIF

    CLOSE(descript%lun)  !close the max/min file

    450 format('Finished reading ',i0,' lines from the "',a,'" file.')

#if defined(GLOBALIO_TRACE) || defined(ALL_TRACE)
    call allMessage(DEBUG,"Return.")
#endif
    call unsetMessageSource()

!-----------------------------------------------------------------------
    end subroutine readMinMax
!-----------------------------------------------------------------------

!----------------------------------------------------------------------
!       S U B R O U T I N E   N D D T 2 R E A D
!----------------------------------------------------------------------

!     tcm v50.66.02 Subroutine to read in new bathymetry values.
!        Time records are separated by a # symbol located in
!        column 2.  This format is similar to those for NWS = 4

!----------------------------------------------------------------------
    SUBROUTINE NDDT2GET(lun,RVAL,defval)
    USE SIZES
    IMPLICIT NONE
    INTEGER :: IJK
    INTEGER, intent(in) :: lun
    REAL(SZ), intent(in) :: defval
    REAL(SZ),intent(inout) ::  rval(*)
    REAL(SZ) :: tmpval
    CHARACTER(80) :: cdum80

    call setMessageSource("nddt2get")
#if defined(GLOBALIO_TRACE) || defined(ALL_TRACE)
    call allMessage(DEBUG,"Enter.")
#endif

!...  go get new record for only some nodes, all
!...  other nodes keep their current value
    170 READ(lun,'(A80)') CDUM80
    IF(CDUM80(2:2) == '#') GOTO 170
    171 READ(CDUM80,'(I8,E13.5)') IJK,tmpval
    if (tmpval /= defval) RVAL(IJK) = tmpval  !this allows us to exclude values included for record separation purposes in the parallel version
    READ(lun,'(A80)',end=172) CDUM80
    IF(CDUM80(2:2) /= '#') GOTO 171
    172 CONTINUE
     
#if defined(GLOBALIO_TRACE) || defined(ALL_TRACE)
    call allMessage(DEBUG,"Return.")
#endif
    call unsetMessageSource()
          
    RETURN
!----------------------------------------------------------------------
    END SUBROUTINE NDDT2GET
!----------------------------------------------------------------------

!-----------------------------------------------------------------------
!     S U B R O U T I N E
!            R E A D  A N D  M A P  T O  S U B D O M A I N  2 D
!                M A X  A N D  M I N
!-----------------------------------------------------------------------
!     TCM v51.20.01 Reads a fulldomain array in ascii format and maps
!     to a subdomain array.  Modeled after readAndMapToSubdomain2D
!     jgf52.08.03: Reduced subroutine arguments to OutputDataDescript_t
!     and an indicator of whether the file was found; removed hardwired
!     variables.
!-----------------------------------------------------------------------
    subroutine readAndMapToSubdomainMaxMin(descript, timeloc, fileFound)
    implicit none
    type(OutputDataDescript_t), intent(inout) :: descript
    real(8), intent(in) :: timeloc ! adcirc time in seconds since cold start
    logical, intent(out) :: fileFound ! .TRUE. if file found and opened
    integer :: fd_node_number
    integer :: sd_node_number
    integer :: ios  ! i/o status

    call setMessageSource("readAndMapToSubdomainMaxMin")
#if defined(GLOBALIO_TRACE) || defined(ALL_TRACE)
    call allMessage(DEBUG,"Enter.")
#endif
    call openFileForRead(descript%lun,trim(descript%file_name), ios)
    if ( ios /= 0 ) then
        fileFound = .FALSE. 
        write(scratchMessage,3333) trim(descript % file_name)
        3333 format('Values from ',(a), &
        ' will not reflect the solution prior to this hotstart.')
        call allMessage(INFO,scratchMessage)
        if (descript % minmax_timestamp.eqv. .TRUE. ) then
            descript % array2(:) = -99999.d0  !tcm v51.20.06
        endif
        close(descript%lun)
#if defined(GLOBALIO_TRACE) || defined(ALL_TRACE)
        call allMessage(DEBUG,"Return.")
#endif
        call unsetMessageSource()
        return  ! early return
    else
        fileFound = .TRUE. 
    endif

! serial
    call readMinMax(descript, timeloc)
    if (mnproc > 1) then
    ! loop over subdomain nodes
        do sd_node_number=1,np
        ! get the corresponding fulldomain node number
            fd_node_number = ABS(descript % imap(sd_node_number))
        ! fill in the subdomain arrays with the corresponding
        ! fulldomain values
            if (descript % isInteger.eqv. .TRUE. ) then
                descript % iarray(sd_node_number) = &
                descript % iarray_g(fd_node_number)
            else
                descript % array(sd_node_number) = &
                descript % array_g(fd_node_number)
            endif
            if (descript % minmax_timestamp.eqv. .TRUE. ) then
                descript % array2(sd_node_number) = &
                descript % array2_g(fd_node_number)
            endif
        end do
    endif

#if defined(GLOBALIO_TRACE) || defined(ALL_TRACE)
    call allMessage(DEBUG,"Return.")
#endif
    call unsetMessageSource()
!----------------------------------------------------------------
    end subroutine readAndMapToSubdomainMaxMin
!----------------------------------------------------------------

!-----------------------------------------------------------------------
!     S U B R O U T I N E   G L O B A L I O   T E R M I N A T E
!-----------------------------------------------------------------------
    SUBROUTINE globalioTerminate(NO_MPI_FINALIZE)
#ifdef CMPI
    USE MESSENGER
#endif
    USE GLOBAL, ONLY : setMessageSource, unsetMessageSource, &
    allMessage, DEBUG, ECHO, INFO, WARNING, ERROR
    IMPLICIT NONE
    LOGICAL, OPTIONAL :: NO_MPI_FINALIZE

    call setMessageSource("globalioTerminate")
#if defined(GLOBALIO_TRACE) || defined(ALL_TRACE)
    call allMessage(DEBUG,"Enter.")
#endif

    call allMessage(INFO,"ADCIRC Terminating.")

#ifdef CMPI
    subdomainFatalError = .TRUE. 
    IF (PRESENT(NO_MPI_FINALIZE)) THEN
        CALL MSG_FINI(NO_MPI_FINALIZE)
    ELSE
        CALL MSG_FINI()
    ENDIF
#endif
    STOP

#if defined(GLOBALIO_TRACE) || defined(ALL_TRACE)
    call allMessage(DEBUG,"Return.") ! should be unreachable
#endif
    call unsetMessageSource()
!-----------------------------------------------------------------------
    END SUBROUTINE globalioTerminate
!-----------------------------------------------------------------------


!-----------------------------------------------------------------------
    end module global_io
!-----------------------------------------------------------------------
