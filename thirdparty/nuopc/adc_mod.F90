!>
!! @mainpage ADCIRC NUOPC Cap
!! @author Saeed Moghimi (moghimis@gmail.com)
!! @date 15/1/17 Original documentation
!------------------------------------------------------
!LOG-----------------
!
module adc_mod

  !-----------------------------------------------------------------------------
  ! ADCIRC mesh utility
  !-----------------------------------------------------------------------------
  use mpi
  use ESMF
  use NUOPC

  use MESH   , only: np,ne,nm,slam,sfea
  use GLOBAL , only: IMAP_EL_LG,NODES_LG
  use GLOBAL , only: ETA2, UU2, VV2  ! Export water level and velocity fileds to wave model
  USE GLOBAL,  ONLY: RSNX2, RSNY2    ! Import wave 2D forces from wave model
  use SIZES  , only: ROOTDIR

  ! DW
  USE GLOBAL, only: CMP_VERSION_NUMBERS, FileFmtVersion

  implicit none

  INTERFACE Read14MeshOnly
    MODULE PROCEDURE read14femesh
  END INTERFACE Read14MeshOnly

    !> \author Ali Samii - 2016
    !! See: https://github.com/samiiali
    !! \brief This object stores the data required for construction of a parallel or serial
    !! ESMF_Mesh from <tt>fort.14, fort.18, partmesh.txt</tt> files.
    !!
   type meshdata
        !> \details vm is an ESMF_VM object.  ESMF_VM is just an ESMF virtual machine class,
        !! which we will use to get the data about the local PE and PE count.
        type(ESMF_VM)                      :: vm

        !> \details This array contains the node coordinates of the mesh. For
        !! example, in a 2D mesh, the \c jth coordinate of the \c nth node
        !! is stored in location <tt> 2*(n-1)+j</tt> of this array.
        real(ESMF_KIND_R8), allocatable    :: NdCoords(:)

        !> \details This array contains the elevation of different nodes of the mesh
        real(ESMF_KIND_R8), allocatable    :: bathymetry(:)

        !> \details Number of nodes present in the current PE. This is different from the
        !! number of nodes owned by this PE (cf. NumOwnedNd)
        integer(ESMF_KIND_I4)              :: NumNd

        !> \details Number of nodes owned by this PE. This is different from the number of
        !! nodes present in the current PE (cf. NumNd)
        integer(ESMF_KIND_I4)              :: NumOwnedNd

        !> \details Number of elements in the current PE. This includes ghost elements and
        !! owned elements. However, we do not bother to distinguish between owned
        !! element and present element (as we did for the nodes).
        integer(ESMF_KIND_I4)              :: NumEl

        !> \details Number of nodes of each element, which is simply three in 2D ADCIRC.
        integer(ESMF_KIND_I4)              :: NumND_per_El

        !> \details Global node numbers of the nodes which are present in the current PE.
        integer(ESMF_KIND_I4), allocatable :: NdIDs(:)

        !> \details Global element numbers which are present in the current PE.
        integer(ESMF_KIND_I4), allocatable :: ElIDs(:)

        !> \details The element connectivity array, for the present elements in the current PE.
        !! The node numbers are the local numbers of the present nodes. All the element
        !! connectivities are arranged in this one-dimensional array.
        integer(ESMF_KIND_I4), allocatable :: ElConnect(:)

        !> \details The element connectivity array, for the present elements in the current PE.
        !! The node numbers are the global numbers of the present nodes. All the element
        !! connectivities are arranged in this one-dimensional array.
        integer(ESMF_KIND_I4), allocatable :: ElConnectG(:)

        !> \details The number of the PE's which own each of the nodes present this PE.
        !! This number is zero-based.
        integer(ESMF_KIND_I4), allocatable :: NdOwners(:)  !  

        !> \details An array containing the element types, which are all triangles in our
        !! application.
        integer(ESMF_KIND_I4), allocatable :: ElTypes(:)

        !> \details This array contains the element coordinates of the mesh. 
        real(ESMF_KIND_R8), allocatable    :: ElCoords(:)

        !> \details This is an array, which maps the indices of the owned nodes to the indices of the present
        !! nodes. For example, assume we are on <tt>PE = 1</tt>, and we have four nodes present, and the
        !! first and third nodes belong to <tt>PE = 0</tt>. So we have:
        !! \code
        !! NumNd = 4
        !! NumOwnedNd = 2
        !! NdOwners = (/0, 1, 0, 1/)
        !! NdIDs = (/2, 3, 5, 6/)
        !! owned_to_present = (/2, 4/)    <-- Because the first node owned by this PE is actually
        !!                                    the second node present on this PE, and so on.
        !! \endcode
        integer(ESMF_KIND_I4), allocatable :: owned_to_present_nodes(:) ! Resident node
    end type meshdata

    ! reading data time management info WW3 <-----> ADC exchange
    integer                       :: adc_cpl_int,adc_cpl_num,adc_cpl_den

    ! module name
    character(*), parameter       :: modName = "(adc_mod)"

    PRIVATE::  EXTRACT_MSG_TABLE_FORT18
  !-----------------------------------------------------------------------------
  contains
    !> \author Ali Samii - 2016
    !! See: https://github.com/samiiali
    !> @details Using the data available in <tt> fort.14, fort.18, partmesh.txt</tt> files
    !! this function extracts the scalars and arrays required for construction of a
    !! meshdata object.
    !! After calling this fucntion, one can call create_parallel_esmf_mesh_from_meshdata()
    !! or create_masked_esmf_mesh_from_data() to create an ESMF_Mesh.
    !! @param vm This is an ESMF_VM object, which will be used to obtain the \c localPE
    !! and \c peCount of the \c MPI_Communicator.
    !! @param global_fort14_dir This is the directory path (relative to the executable
    !! or an absolute path) which contains the global \c fort.14 file (not the fort.14
    !! after decomposition).
    !! @param the_data This is the output meshdata object.
    !!

    !> \details As the name of this function suggests, this funciton creates a parallel
    !! ESMF_Mesh from meshdata object. This function should be called collectively by
    !! all PEs for the parallel mesh to be created. The function, extract_parallel_data_from_mesh()
    !! should be called prior to calling this function.
    !! \param the_data This the input meshdata object.
    !! \param out_esmf_mesh This is the ouput ESMF_Mesh object.
    subroutine create_parallel_esmf_mesh_from_meshdata(the_data, meshloc, out_esmf_mesh)
        implicit none
        type(ESMF_Mesh), intent(out)   :: out_esmf_mesh
        type(meshdata), intent(in)     :: the_data
        type(ESMF_MeshLoc), intent(in) :: meshloc
        integer, parameter             :: dim1=2, spacedim=2, NumND_per_El=3
        type(ESMF_Distgrid)            :: nodeDistgrid, elementDistgrid
        integer                        :: rc

        if (meshloc /= ESMF_MESHLOC_ELEMENT) then 
           out_esmf_mesh=ESMF_MeshCreate(parametricDim=dim1, spatialDim=spacedim, &
            nodeIDs=the_data%NdIDs, nodeCoords=the_data%NdCoords, &
            nodeOwners=the_data%NdOwners, elementIDs=the_data%ElIDs, &
            elementTypes=the_data%ElTypes, elementConn=the_data%ElConnect, &
            rc=rc)

           if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
               line=__LINE__, &
               file=__FILE__)) &
               return  ! bail out
        else
           ! create node distgrid
           nodeDistgrid = ESMF_DistgridCreate(the_data%NdIDs, rc=rc)

           if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
               line=__LINE__, &
               file=__FILE__)) &
               return  ! bail out

           ! create element distgrid
           elementDistgrid = ESMF_DistgridCreate(the_data%ElIDs, rc=rc)

           if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
               line=__LINE__, &
               file=__FILE__)) &
               return  ! bail out

           ! create mesh
           out_esmf_mesh=ESMF_MeshCreate(parametricDim=dim1, spatialDim=spacedim, &
               nodeIDs=abs(the_data%NdIDs), &
               nodeCoords=the_data%NdCoords, &
               nodeOwners=the_data%NdOwners, &
               nodalDistgrid=nodeDistgrid, &
               elementIDs=abs(the_data%ElIDs), &
               elementTypes=the_data%ElTypes, &
               elementConn=the_data%ElConnect, &
               elementCoords=the_data%ElCoords, &
               elementDistgrid=elementDistgrid, &
               coordSys=ESMF_COORDSYS_SPH_DEG, &
               rc=rc)

           if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
               line=__LINE__, &
               file=__FILE__)) &
               return  ! bail out
        end if

    end subroutine
    !
    !> \author Ali Samii - 2016
    !! See: https://github.com/samiiali
    !> @details Using the data available in <tt> fort.14, fort.18, partmesh.txt</tt> files
    !! this function extracts the scalars and arrays required for construction of a
    !! meshdata object.
    !! After calling this fucntion, one can call create_parallel_esmf_mesh_from_meshdata()
    !! or create_masked_esmf_mesh_from_data() to create an ESMF_Mesh.
    !! @param vm This is an ESMF_VM object, which will be used to obtain the \c localPE
    !! and \c peCount of the \c MPI_Communicator.
    !! @param global_fort14_dir This is the directory path (relative to the executable
    !! or an absolute path) which contains the global \c fort.14 file (not the fort.14
    !! after decomposition).
    !! @param the_data This is the output meshdata object.
    !!
    subroutine extract_parallel_data_from_mesh(global_fort14_dir, the_data,localPet)
        implicit none
        type(meshdata), intent(inout)         :: the_data
        character(len=*), intent(in)          :: global_fort14_dir
        character(len=200)                    :: partmesh_filename
        integer, intent(in)                   :: localPet
        integer                               :: i1, j1, i_num, num_global_nodes,io,garbage2
        integer, allocatable                  :: local_node_numbers(:), local_elem_numbers(:), node_owner(:)
        integer, parameter                    :: dim1=2, NumND_per_El=3

        the_data%NumNd = np
        the_data%NumEl = ne
        allocate(the_data%NdIDs(the_data%NumNd))
        allocate(local_node_numbers(the_data%NumNd))
        allocate(the_data%ElIDs(the_data%NumEl))
        allocate(local_elem_numbers(the_data%NumEl))
        allocate(the_data%NdCoords(dim1*the_data%NumNd))
        allocate(the_data%bathymetry(the_data%NumNd))
        allocate(the_data%ElConnect(NumND_per_El*the_data%NumEl))
        allocate(the_data%NdOwners(the_data%NumNd))
        allocate(the_data%ElTypes(the_data%NumEl))

        local_elem_numbers = IMAP_EL_LG
        the_data%ElIDs = abs(local_elem_numbers)
        local_node_numbers = NODES_LG
        the_data%NumOwnedND = 0

        do i1 = 1, the_data%NumNd, 1
            if (local_node_numbers(i1) > 0) then
                the_data%NumOwnedND = the_data%NumOwnedND + 1
            end if
        end do
        the_data%NdIDs = abs(local_node_numbers)
        allocate(the_data%owned_to_present_nodes(the_data%NumOwnedND))

        !> @details Read partmesh file to get global node information
        !print *, 'size local_elem_numbers', size(local_elem_numbers),size(IMAP_EL_LG)
        !print *, 'size local_node_numbers', size(local_node_numbers),size(NODES_LG)

        !partmesh_filename = trim(global_fort14_dir//"/partmesh.txt")
        open(unit=10099, file = TRIM(global_fort14_dir)//'/'//'partmesh.txt', &
            form='FORMATTED', status='OLD', action='READ')

        !! Very ugly way of finding global element numebr
        !! TODO: Saeed: need to find the reprsentive value for this
        num_global_nodes = 0
        do
            read(unit=10099,fmt=*,iostat=io) garbage2
            if (io/=0) exit
            num_global_nodes = num_global_nodes + 1
        end do
        rewind(unit=10099)
        !
        !print *, 'size num_global_nodes', num_global_nodes,localPet

        allocate(node_owner(num_global_nodes))
        read(unit=10099, fmt=*) node_owner
        close(10099)


        !print *, 'ADC SLAM > ',size(slam),'>>>>>>',slam
        !print *, 'ADC SFEA > ',size(sfea),'>>>>>>',sfea
        
        do i1 = 1, the_data%NumNd, 1
                the_data%NdCoords((i1-1)*dim1 + 1) = slam(i1)
                the_data%NdCoords((i1-1)*dim1 + 2) = sfea(i1)
        end do
        do i1 = 1, the_data%NumEl, 1
                the_data%ElConnect((i1-1)*NumND_per_El+1) = nm (i1,1)
                the_data%ElConnect((i1-1)*NumND_per_El+2) = nm (i1,2)
                the_data%ElConnect((i1-1)*NumND_per_El+3) = nm (i1,3)
        end do

        do i1= 1, the_data%NumNd, 1
            the_data%NdOwners(i1) = node_owner(the_data%NdIDs(i1)) - 1
        end do

        j1 = 0
        do i1 = 1, the_data%NumNd, 1
            if (the_data%NdOwners(i1) == localPet) then
                j1 = j1 + 1
                the_data%owned_to_present_nodes(j1) = i1
            end if
        end do
        the_data%ElTypes = ESMF_MESHELEMTYPE_TRI

        !TODO: Saeed: Check if I need to dealocate arrays here!

    end subroutine extract_parallel_data_from_mesh


    !
    ! DW:
    !   - extract message data from PExxxx/fort.18  
    !   - extract mesh from   PExxxx/fort.14
    subroutine extract_parallel_data_from_mesh_orig(global_fort14_dir, the_data, localPet, meshloc)
        implicit none

        type(meshdata), intent(inout)         :: the_data
        character(len=*), intent(in)          :: global_fort14_dir
        integer, intent(in)                   :: localPet
        type(ESMF_MeshLoc), intent(in)        :: meshloc          
        character(len=6)                      :: PE_ID, garbage1
        
        character(len=200)                    :: fort14_filename, fort18_filename, partmesh_filename
        integer                               :: i1, j1, i_num, petCount, num_global_nodes, garbage2, garbage3
        integer, allocatable                  :: local_node_numbers(:), local_elem_numbers(:), node_owner(:)
        integer, parameter                    :: dim1=2, NumND_per_El=3

        ! for reading localized fort.14
        INTEGER:: nn(2)
        INTEGER, ALLOCATABLE:: etov(:,:)  ! element table
        INTEGER, ALLOCATABLE:: etog(:,:)  ! element table, global
        REAL(8), ALLOCATABLE:: vx(:,:), bxy(:) ! node coordinates, bathymetry
        REAL(8), ALLOCATABLE:: xc(:,:)  ! element coordinates 
        character(len=1024)   :: msgString


        write(PE_ID, "(A,I4.4)") "PE", localPet
        fort14_filename = TRIM(global_fort14_dir)//'/'//PE_ID//"/fort.14"
        fort18_filename = TRIM(global_fort14_dir)//'/'//PE_ID//"/fort.18"
        partmesh_filename = TRIM(global_fort14_dir)//'/'//'partmesh.txt'

        open(unit=23514, file=fort14_filename, form='FORMATTED', status='OLD', action='READ')
!       open(unit=23518, file=fort18_filename, form='FORMATTED', status='OLD', action='READ')
!       open(unit=235100, file=partmesh_filename, form='FORMATTED', status='OLD', action='READ')

        read(unit=23514, fmt=*)
        read(unit=23514, fmt=*) the_data%NumEl, the_data%NumNd 

        allocate(the_data%NdIDs(the_data%NumNd))
        allocate(local_node_numbers(the_data%NumNd))
        allocate(the_data%ElIDs(the_data%NumEl))
        allocate(local_elem_numbers(the_data%NumEl))
        allocate(the_data%NdCoords(dim1*the_data%NumNd))
        allocate(the_data%bathymetry(the_data%NumNd))
        allocate(the_data%ElConnect(NumND_per_El*the_data%NumEl))
        allocate(the_data%ElConnectG(NumND_per_El*the_data%NumEl))
        allocate(the_data%NdOwners(the_data%NumNd))
        allocate(the_data%ElTypes(the_data%NumEl))
        allocate(the_data%ElCoords(dim1*the_data%NumEl))

        the_data%ElTypes = ESMF_MESHELEMTYPE_TRI
        CALL EXTRACT_MSG_TABLE_FORT18( fort18_filename, the_data, meshloc)

!        !  todo: Modify reading fort.18 using the same procedure as reading fort18 in messenger.F
!        read(unit=23518, fmt=*)
!        read(unit=23518, fmt=*)
!        read(unit=23518, fmt=*) local_elem_numbers
!        the_data%ElIDs = abs(local_elem_numbers)
!        read(unit=23518, fmt=*) garbage1, num_global_nodes, garbage2, garbage3
!        read(unit=23518, fmt=*) local_node_numbers
!        the_data%NumOwnedND = 0
!        do i1 = 1, the_data%NumNd, 1
!            if (local_node_numbers(i1) > 0) then
!                the_data%NumOwnedND = the_data%NumOwnedND + 1
!            end if
!        end do
!        the_data%NdIDs = abs(local_node_numbers)
!        allocate(node_owner(num_global_nodes))
!        allocate(the_data%owned_to_present_nodes(the_data%NumOwnedND))
!        read(unit=235100, fmt=*) node_owner
!
!        !print *, 'ADC SLAM > ',size(slam),'>>>>>>',minval(slam),maxval(slam)
!        !print *, 'ADC SFEA > ',size(sfea),'>>>>>>',minval(sfea),maxval(sfea)
!

        close( 23514 ) ; 
        CALL Read14MeshOnly( meshfileName=fort14_filename, nn=nn, vx=vx, etov=etov, etog=etog, bxy=bxy  ) ;
        
        the_data%NdCoords = reshape( vx, (/ 2*the_data%NumNd /) ) ;
        the_data%ElConnect = reshape( etov, (/ NumND_per_El*the_data%NumEl /) ) ;  
        the_data%ElConnectG = reshape( etog, (/ NumND_per_El*the_data%NumEl /) ) ;
        the_data%bathymetry = bxy ;    

        ! construct element coordinates
        if (.not. allocated(xc)) allocate(xc(2,ne))
        xc(:,:) = 0.0
        do i1 = 1, the_data%NumEl, 1
           xc(1,i1) = xc(1,i1) + sum(vx(1,etov(:,i1)))/3.0  ;
           xc(2,i1) = xc(2,i1) + sum(vx(2,etov(:,i1)))/3.0   ;
        end do

        the_data%ElCoords = reshape( xc, (/ 2*the_data%NumEl /) ) ;

!        ! todo: will have to use hash table from v55
!        do i1 = 1, the_data%NumNd, 1
!            read(unit=23514, fmt=*) local_node_numbers(i1), &
!                the_data%NdCoords((i1-1)*dim1 + 1), &
!                the_data%NdCoords((i1-1)*dim1 + 2), &
!                the_data%bathymetry(i1)
!        end do
!        !i1=100
!        !print *,'ADC > lon,lat >>', the_data%NdCoords((i1-1)*dim1 + 1),  the_data%NdCoords((i1-1)*dim1 + 2)
!        !i1=400
!        !print *,'ADC > lon,lat >>', the_data%NdCoords((i1-1)*dim1 + 1),  the_data%NdCoords((i1-1)*dim1 + 2)
!        
!        do i1 = 1, the_data%NumEl, 1
!            read(unit=23514, fmt=*) local_elem_numbers(i1), i_num, &
!                the_data%ElConnect((i1-1)*NumND_per_El+1), &
!                the_data%ElConnect((i1-1)*NumND_per_El+2), &
!                the_data%ElConnect((i1-1)*NumND_per_El+3)
!        end do


!------ this information is now extracted from fort.18
!        do i1= 1, the_data%NumNd, 1
!            the_data%NdOwners(i1) = node_owner(the_data%NdIDs(i1)) - 1
!        end do
!
!        j1 = 0
!        do i1 = 1, the_data%NumNd, 1
!            if (the_data%NdOwners(i1) == localPet) then
!                j1 = j1 + 1
!                the_data%owned_to_present_nodes(j1) = i1
!            end if
!        end do
!        the_data%ElTypes = ESMF_MESHELEMTYPE_TRI

!        close(23514)
!        close(23518)
!        close(235100)

        ! free memeory 
        DEALLOCATE( vx, etov, bxy, xc ) ;

        RETURN
    end subroutine extract_parallel_data_from_mesh_orig

    !-----------------------------------------------------------------------------
    subroutine eliminate_ghosts(the_data, localPet, dbug)
        implicit none

        type(meshdata), intent(inout) :: the_data
        integer, intent(in)           :: localPet
        logical, intent(in)           :: dbug

        ! local variables
        integer :: i, j, k, indx, indx2
        integer :: n1, i1, j1, pe1, n2, i2, j2, pe2, n3, i3, j3, pe3
        integer :: minNdIDs, maxNdIDs
        integer :: NumEl_nog, NumNd_nog
        integer :: NumND_per_El = 3
        integer :: dim1 = 2
        integer, allocatable  :: ElIDs(:)
        integer, allocatable  :: ElConnect(:)
        integer, allocatable  :: ElConnectG(:)
        real(ESMF_KIND_R8), allocatable :: ElCoords(:)
        integer, allocatable  :: ElMask(:)
        integer, allocatable  :: NdIDs(:)
        real(ESMF_KIND_R8), allocatable :: NdCoords(:)
        integer, allocatable  :: NdOwners(:)
        real(ESMF_KIND_R8), allocatable :: bathymetry(:)
        integer, allocatable  :: NdMask(:)
        character(len=1024)   :: msgString
        character(len=*), parameter :: subname=trim(modName)//':(eliminate_ghosts) '

        ! message for entering call
        call ESMF_LogWrite(subname//' called', ESMF_LOGMSG_INFO)

        ! create mask for elements
        if (.not. allocated(ElMask)) allocate(ElMask(the_data%NumEl))
        ElMask = 0

        do i = 1, the_data%NumEl
           ! add if element id > 0
           if (the_data%ElIDs(i) > 0) then
              ElMask(i) = the_data%ElIDs(i)
           end if
        end do

        ! debug
        if (dbug) then
           do i = 1, the_data%NumEl
              ! get node owners
              pe1 = the_data%NdOwners(the_data%ElConnect((i-1)*NumND_per_El+1))
              pe2 = the_data%NdOwners(the_data%ElConnect((i-1)*NumND_per_El+2))
              pe3 = the_data%NdOwners(the_data%ElConnect((i-1)*NumND_per_El+3))

              write(msgString,'(8I8)') the_data%ElIDs(i), ElMask(i), pe1, pe2, pe3, &
                the_data%ElConnectG((i-1)*NumND_per_El+1), &
                the_data%ElConnectG((i-1)*NumND_per_El+2), &
                the_data%ElConnectG((i-1)*NumND_per_El+3)
              call ESMF_LogWrite(subname//' EMASK: '//trim(msgString), ESMF_LOGMSG_INFO)
           end do
        end if

        ElMask = abs(ElMask)

        ! number of elements without ghosts
        NumEl_nog = count(mask=ElMask > 0)
        write(msgString,'(A,I8,A,I8)') 'NumEl = ', size(the_data%ElIDs), ' NumEl_no_ghost = ', NumEl_nog
        if (dbug) call ESMF_LogWrite(subname//' '//trim(msgString), ESMF_LOGMSG_INFO)

        ! allocate temporary arrays for element
        if (.not. allocated(ElIDs)) allocate(ElIDs(NumEl_nog))
        if (.not. allocated(ElConnect)) allocate(ElConnect(NumND_per_El*NumEl_nog)) 
        if (.not. allocated(ElConnectG)) allocate(ElConnectG(NumND_per_El*NumEl_nog)) 
        if (.not. allocated(ElCoords)) allocate(ElCoords(dim1*NumEl_nog))

        ! fill temporary element arrays with non-ghost data
        j = 1
        do i = 1, the_data%NumEl   
           if (ElMask(i) > 0) then
              ElIDs(j) = the_data%ElIDs(i)
              ElConnect((j-1)*NumND_per_El+1) = the_data%ElConnect((i-1)*NumND_per_El+1)
              ElConnect((j-1)*NumND_per_El+2) = the_data%ElConnect((i-1)*NumND_per_El+2)
              ElConnect((j-1)*NumND_per_El+3) = the_data%ElConnect((i-1)*NumND_per_El+3)
              ElConnectG((j-1)*NumND_per_El+1) = the_data%ElConnectG((i-1)*NumND_per_El+1)
              ElConnectG((j-1)*NumND_per_El+2) = the_data%ElConnectG((i-1)*NumND_per_El+2)
              ElConnectG((j-1)*NumND_per_El+3) = the_data%ElConnectG((i-1)*NumND_per_El+3)
              ElCoords((j-1)*dim1+1) = the_data%ElCoords((i-1)*dim1+1)
              ElCoords((j-1)*dim1+2) = the_data%ElCoords((i-1)*dim1+2)
              j = j+1
           end if
        end do
        deallocate(ElMask)

        ! make local node ids in ElConnect monotonic again since we removed ghosts elements
        minNdIDs = minval(ElConnect, dim=1)
        maxNdIDs = maxval(ElConnect, dim=1)
        write(msgString,'(2I8)') minNdIDs, maxNdIDs
        if (dbug) call ESMF_LogWrite(subname//' minNdIDs, maxNdIDs: '//trim(msgString), ESMF_LOGMSG_INFO)

        ! create mask for unique list of nodes in the element connection
        if (.not. allocated(NdMask)) allocate(NdMask(the_data%NumNd))
        NdMask = 0

        do i = 1, NumEl_nog
           n1 = ElConnectG((i-1)*NumND_per_El+1)
           i1 = findloc(abs(the_data%NdIDs), n1, dim=1)
           if (NdMask(i1) == 0) NdMask(i1) = ElConnect((i-1)*NumND_per_El+1)

           n2 = ElConnectG((i-1)*NumND_per_El+2)
           i2 = findloc(abs(the_data%NdIDs), n2, dim=1)
           if (NdMask(i2) == 0) NdMask(i2) = ElConnect((i-1)*NumND_per_El+2)

           n3 = ElConnectG((i-1)*NumND_per_El+3)
           i3 = findloc(abs(the_data%NdIDs), n3, dim=1)
           if (NdMask(i3) == 0) NdMask(i3) = ElConnect((i-1)*NumND_per_El+3)
        end do

        ! debug, print nodeids and associated masks
        if (dbug) then
           do i = 1, the_data%NumNd
              write(msgString,'(3I8)') the_data%NdIDs(i), NdMask(i), the_data%NdOwners(i)
              call ESMF_LogWrite(subname//' NMASK: '//trim(msgString), ESMF_LOGMSG_INFO)
           end do
        end if

        ! number of nodes without ghosts
        NumNd_nog = count(mask=NdMask .gt. 0)
        write(msgString,'(A,I8,A,I8)') 'NumNd = ', size(the_data%NdIDs), ' NumNd_no_ghost = ', NumNd_nog
        if (dbug) call ESMF_LogWrite(subname//' '//trim(msgString), ESMF_LOGMSG_INFO)
        write(msgString,'(A,2I8)') 'NdMask min/max = ', minval(NdMask, dim=1, mask=NdMask .gt. 0), maxval(NdMask, dim=1, mask=NdMask .gt. 0)
        if (dbug) call ESMF_LogWrite(subname//' '//trim(msgString), ESMF_LOGMSG_INFO)

        ! allocate temporary arrays for node 
        if (.not. allocated(NdIDs)) allocate(NdIDs(NumNd_nog))
        if (.not. allocated(NdCoords)) allocate(NdCoords(dim1*NumNd_nog))
        if (.not. allocated(NdOwners)) allocate(NdOwners(NumNd_nog))
        if (.not. allocated(bathymetry)) allocate(bathymetry(NumNd_nog))

        ! fill temporary node arrays with non-ghost data
        ! node ids in the node list are global ids
        j = 1
        do i = 1, the_data%NumNd
           if (NdMask(i) .ne. 0) then 
              NdIDs(j) = the_data%NdIDs(i)
              NdCoords((j-1)*dim1+1) = the_data%NdCoords((i-1)*dim1+1)
              NdCoords((j-1)*dim1+2) = the_data%NdCoords((i-1)*dim1+2)
              NdOwners(j) = the_data%NdOwners(i)
              bathymetry(j) = the_data%bathymetry(i)
              j = j+1
           end if
        end do
        deallocate(NdMask)

        ! make nodeids local again in the element connection
        k = 0
        do i = minNdIDs, maxNdIDs
           j = findloc(ElConnect, i, dim=1)
           if (j > 0) then
              k = k+1
              where (ElConnect == i) ElConnect = -k
           end if
        end do
        ElConnect = abs(ElConnect)

        ! update data with non-ghost one
        the_data%NumEl = NumEl_nog

        if (allocated(the_data%ElIDs)) then
           deallocate(the_data%ElIDs)
           allocate(the_data%ElIDs(NumEl_nog))
           the_data%ElIDs = ElIDs
           deallocate(ElIDs)
        end if

        if (allocated(the_data%ElConnect)) then
           deallocate(the_data%ElConnect)
           allocate(the_data%ElConnect(NumND_per_El*NumEl_nog))
           the_data%ElConnect = ElConnect
           deallocate(ElConnect)
        end if

        if (allocated(the_data%ElConnectG)) then
           deallocate(the_data%ElConnectG)
           allocate(the_data%ElConnectG(NumND_per_El*NumEl_nog))
           the_data%ElConnectG = ElConnectG
           deallocate(ElConnectG)
        end if

        if (allocated(the_data%ElCoords)) then
           deallocate(the_data%ElCoords)
           allocate(the_data%ElCoords(dim1*NumEl_nog))
           the_data%ElCoords = ElCoords
           deallocate(ElCoords)
        end if

        if (allocated(the_data%ElTypes)) then
           deallocate(the_data%ElTypes)
           allocate(the_data%ElTypes(NumEl_nog))
           the_data%ElTypes = ESMF_MESHELEMTYPE_TRI
        end if

        the_data%NumNd = NumNd_nog

        if (allocated(the_data%NdIDs)) then
           deallocate(the_data%NdIDs)
           allocate(the_data%NdIDs(NumNd_nog))
           the_data%NdIDs = NdIDs
           deallocate(NdIDs)
        end if

        if (allocated(the_data%NdCoords)) then
           deallocate(the_data%NdCoords)
           allocate(the_data%NdCoords(dim1*NumNd_nog))
           the_data%NdCoords = NdCoords
           deallocate(NdCoords)
        end if

        if (allocated(the_data%NdOwners)) then
           deallocate(the_data%NdOwners)
           allocate(the_data%NdOwners(NumNd_nog))
           the_data%NdOwners = NdOwners
           deallocate(NdOwners)
        end if

        if (allocated(the_data%bathymetry)) then
           deallocate(the_data%bathymetry)
           allocate(the_data%bathymetry(NumNd_nog))
           the_data%bathymetry = bathymetry
           deallocate(bathymetry)
        end if

        if (dbug) then
           ! debug, output local, global ids and coordinates of nodes accociated with element
           do i = 1, the_data%NumEl
              write(msgString,'(7I8,2F8.3)') the_data%ElIDs(i), &
                the_data%ElConnect((i-1)*NumND_per_El+1), the_data%ElConnect((i-1)*NumND_per_El+2), the_data%ElConnect((i-1)*NumND_per_El+3), &
                the_data%ElConnectG((i-1)*NumND_per_El+1), the_data%ElConnectG((i-1)*NumND_per_El+2), the_data%ElConnectG((i-1)*NumND_per_El+3), &
                the_data%ElCoords((i-1)*dim1+1), the_data%ElCoords((i-1)*dim1+2)
              call ESMF_LogWrite(subname//' ELEM: '//trim(msgString), ESMF_LOGMSG_INFO)
           end do

           ! debug, output nodeid, owners and coordinates
           do i = 1, the_data%NumNd
              write(msgString,'(2I8,3F10.3)') the_data%NdIDs(i), the_data%NdOwners(i), &
                the_data%NdCoords((i-1)*dim1+1), the_data%NdCoords((i-1)*dim1+2), &
                the_data%bathymetry(i)
              call ESMF_LogWrite(subname//' NODE: '//trim(msgString), ESMF_LOGMSG_INFO)
           end do
        end if

        ! message for exiting call
        call ESMF_LogWrite(subname//' done', ESMF_LOGMSG_INFO)

    end subroutine eliminate_ghosts

!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
!CC   DW --- Taken from MSG_TABLE() in messenger.F 
      SUBROUTINE EXTRACT_MSG_TABLE_FORT18( fort18_filename, the_data, meshloc )
        IMPLICIT NONE

        CHARACTER (LEN=*):: fort18_filename 
        type (meshdata), intent(inout):: the_data
        type (ESMF_MeshLoc) :: meshloc

        ! local !
        INTEGER :: IDPROC, NLOCAL, I, J, jdumy_loc
        INTEGER :: jdumy, jdumy_G, jdumy_max, inputFileFmtVn
        CHARACTER(10) :: BlkName
        LOGICAL FileFound

        
        INTEGER:: funit
        INTEGER:: NE_G_TMP, NP_G_TMP, NEIGHPROC_TMP, idrecvnode
        INTEGER, ALLOCATABLE:: IPROC_TMP(:), NNODRECV_TMP(:), IRECVLOC_TMP(:, :) 

!C
        funit = 23518 ; 
        open(unit=funit, file=fort18_filename, form='FORMATTED', status='OLD', action='READ')
        READ(funit,3020) BlkName, inputFileFmtVn
        if ( Trim(BlkName) /= 'FileFmt' .and. &
           .not. CMP_VERSION_NUMBERS(FileFmtVersion, inputFileFmtVn) ) then
            write(*,*) 'Error: file Format of Fort.18 does not match aborting'
          stop
        end if

!C Read Global number of elements and Local-to_Global element map ( used by module global_io )
!c Casey 100209: Changed from FMT=3015.
        READ(funit,'(8X,3I12)') NE_G_TMP
        DO I=1, the_data%NumEl  ! MNE   
          READ(funit,*) the_data%ElIDs(I) ; 
        ENDDO
        if (meshloc /= ESMF_MESHLOC_ELEMENT) the_data%ElIDs = abs(the_data%ElIDs)

!C Read Global number of nodes and Local-to_Global node map ( used by module global_io )
        READ(funit,3015) NP_G_TMP
        DO I=1, the_data%NumNd ! MNP
            READ(funit,*) the_data%NdIds(I) ; 
        ENDDO
        if (meshloc /= ESMF_MESHLOC_ELEMENT) the_data%NdIds = abs(the_data%NdIds) ; 

!C  This information is provided for relocalizing fort.15
!C  Just read past it.
        READ(funit,'(8X,I12)') jdumy   ! nfluxf for subdomain
 
        CALL SKIP_STATION_READING( funit, 'skip reading neta') ; ! Skip neta for subdomain
        CALL SKIP_STATION_READING( funit, 'skip reading stae') ; ! Skip global index of elevation stations for subdomain
        CALL SKIP_STATION_READING( funit, 'skip reading stav') ; ! Skip global index of veclocity stations
        CALL SKIP_STATION_READING( funit, 'skip reading stam') ; ! Skip global index of meteorlogical stations
        CALL SKIP_STATION_READING( funit, 'skip reading stac') ; ! Skip global index of concentration stations

!C---------------------------------------------------------------------------------
!C--Message-Passing tables start here
!C---------------------------------------------------------------------------------

        !
        ! --  Resident nodes
        !
        READ(funit,3010) IDPROC, NLOCAL ! PE, No. of Res node
        the_data%NumOwnedND = NLOCAL ; 

        ALLOCATE( the_data%owned_to_present_nodes(the_data%NumOwnedND) ) 
        READ(funit,1130) (the_data%owned_to_present_nodes(I), I=1,  NLOCAL)

        the_data%NdOwners = -9999
        DO I=1, NLOCAL
           the_data%NdOwners( the_data%owned_to_present_nodes(I) ) = IDPROC ; 
        ENDDO

        !
        ! -- Ghost nodes: receiving node
        !
        READ(funit,3015) NEIGHPROC_TMP

        ALLOCATE( IPROC_TMP(NEIGHPROC_TMP), NNODRECV_TMP(NEIGHPROC_TMP) )
        ALLOCATE( IRECVLOC_TMP(the_data%NumNd, NEIGHPROC_TMP) )

        DO J=1, NEIGHPROC_TMP
           READ(funit,3010) IPROC_TMP(J), NNODRECV_TMP(J)
           READ(funit,1130) (IRECVLOC_TMP(I,J), I=1,NNODRECV_TMP(J))
        ENDDO

        DO J = 1, NEIGHPROC_TMP
           !
           DO I = 1, NNODRECV_TMP(J)
              !
              idrecvnode = IRECVLOC_TMP(I,J) ;  
              IF ( the_data%NdOwners(idrecvnode)  == -9999 ) THEN
                 the_data%NdOwners(idrecvnode) = IPROC_TMP(J) ;
              ELSE
                 !c the node is owned by two or more PEs(!) ! 
                 WRITE(*,'(A,I0.4,A,I6,A,I0.4,A,I0.4,A)') 'Warning: PE', &
                   IDPROC, " Recv Node = ",  idrecvnode, " is owned by PE = ", &
                   IPROC_TMP(J), " and ", the_data%NdOwners(idrecvnode), ". Use the latter PE"   ;     
              ENDIF  
           END DO
           !
        END DO 
        ! We are done here the rest does not seem to be required        

!c     ! Sending node (a resident node that is a ghost node of the neighbor PE)
!      ALLOCATE( NNODSEND(NEIGHPROC_TMP) )
!      ALLOCATE( ISENDLOC(MNP,NEIGHPROC_TMP) )
!
!      DO J=1,NEIGHPROC_TMP
!         READ(funit,3010) IPROC_TMP(J),NNODSEND(J)
!         READ(funit,1130) (ISENDLOC(I,J), I=1,NNODSEND(J))
!      ENDDO
!
!C     jgf49.43.18: Add 3D station mappings if appropriate. Used by globalio.
!      IF (C3D) THEN
!         READ(funit,3015) NSTA3DD_G
!         IF (NSTA3DD > 0) THEN
!            ALLOCATE ( IMAP_STA3DD_LG(NSTA3DD) )
!            DO I=1,NSTA3DD
!               READ(funit,'(I12)') IMAP_STA3DD_LG(I)
!            ENDDO
!         ENDIF
!
!         READ(funit,3015) NSTA3DV_G
!         IF (NSTA3DV > 0) THEN
!            ALLOCATE ( IMAP_STA3DV_LG(NSTA3DV) )
!            DO I=1,NSTA3DV
!               READ(funit,'(I12)') IMAP_STA3DV_LG(I)
!            ENDDO
!         ENDIF
!
!         READ(funit,3015) NSTA3DT_G
!         IF (NSTA3DT > 0) THEN
!            ALLOCATE ( IMAP_STA3DT_LG(NSTA3DT) )
!            DO I=1,NSTA3DT
!               READ(funit,'(I12)') IMAP_STA3DT_LG(I)
!            ENDDO
!         ENDIF
!      ENDIF
!
        close(funit) ! close the file

        ! free memory
        DEALLOCATE( IPROC_TMP, NNODRECV_TMP )
        DEALLOCATE( IRECVLOC_TMP )

1130    FORMAT(8X,6I12)
3010    FORMAT(8X,2I12)
3015    FORMAT(8X,3I12)
3020    format(a8,I12)
9973    FORMAT(/,1X,'!!!!!! EXECUTION WILL NOW BE TERMINATED !!!!!!',//)
!C
        RETURN ;

      CONTAINS

!----------------------- Sub function ------------------ 
        SUBROUTINE SKIP_STATION_READING( funit, msg ) !c make this a private function  
          IMPLICIT NONE
    
          INTEGER:: funit
          CHARACTER (LEN=*):: msg

          INTEGER:: jdummy_g, jdummy_max, jdummy_loc

          READ(funit,'(8X,3I12)') jdumy_g, jdumy_max, jdumy_loc ! neta for subdomain
          DO I=1, jdumy_loc
             READ(funit,'(I12)') jdumy                          ! obnode_lg table
          ENDDO

!C  Global indexes of Elevation Station nodes 
!C  Just read past it 
!        READ(funit,3015) jdummy, jdumy_max, jdumy_loc    !tcm v51.20.05
!        IF ( jdummy_loc > 0) THEN
!           DO I=1, jdummy_loc
!!             READ(funit,'(I12)') IMAP_STAE_LG(I)
!             READ(funit,'(I12)') jdummy
!           ENDDO
!        ENDIF
!
!C  Global indexes of Velocity  Station nodes 
!c  Just read past it
!        READ(funit,3015) jdummy, jdumy_max, jdumy_loc    !tcm v51.20.05
!        IF ( jdummy_loc > 0) THEN
!          DO I=1, jdummy_loc
!!           READ(funit,'(I12)') IMAP_STAV_LG(I)
!            READ(funit,'(I12)') jdummy
!          ENDDO
!        ENDIF
!
!C Global indexes of Meteorlogical Station nodes 
!C Just read past it
!      READ(funit,3015) jdummy, jdumy_max, jdumy_loc    !tcm v51.20.05
!      IF ( jdummy_loc > 0) THEN
!        DO I=1,  jdummy_loc
!           READ(funit,'(I12)') jdummy
!        ENDDO
!      ENDIF
!
!C Global indexes of Concentration Station nodes ( used by module global_io )
!      READ(funit,3015) NSTAC_G,jdumy_max,jdumy_loc    !tcm v51.20.05
!      IF (NSTAC .ne. jdumy_loc ) then
!         call allMessage(ERROR,"Conc. Station Dimensioning Error in fort.18")
!         CALL MSG_FINI()
!         STOP
!      ENDIF
!      IF (NSTAC > 0) THEN
!        ALLOCATE ( IMAP_STAC_LG(NSTAC) )
!        DO I=1,NSTAC
!           READ(funit,'(I12)') IMAP_STAC_LG(I)
!        ENDDO
!      ENDIF
       
          RETURN ;
        END SUBROUTINE SKIP_STATION_READING

 
      END SUBROUTINE EXTRACT_MSG_TABLE_FORT18
!CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

    subroutine read_config()
     implicit none 
    ! This subroutine is not used with NEMS system. Because the 
    ! time interval information is passed via nems.configure file 
    ! with time slot definitation.

    
    character(ESMF_MAXPATHLEN)    :: fname ! config file name
    type(ESMF_Config)             :: cf     ! the Config itself
    integer                       :: rc

    rc = ESMF_SUCCESS
    
   !Initiate reading resource file
    cf = ESMF_ConfigCreate(rc=rc)  ! Create the empty Config
    if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
      line=__LINE__, &
      file=__FILE__)) &
      return  ! bail out

    fname = "config.rc" ! Name the Resource File
    call ESMF_ConfigLoadFile(cf, fname, rc=rc) ! Load the Resource File
    if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
      line=__LINE__, &
      file=__FILE__)) &
      return  ! bail out

   ! read time coupling interval info
   
    call ESMF_ConfigGetAttribute(cf, adc_cpl_int, label="cpl_int:",default=300, rc=rc)
    call ESMF_ConfigGetAttribute(cf, adc_cpl_num, label="cpl_num:",default=0  , rc=rc)
    call ESMF_ConfigGetAttribute(cf, adc_cpl_den, label="cpl_den:",default=1  , rc=rc)
    if (ESMF_LogFoundError(rcToCheck=rc, msg=ESMF_LOGERR_PASSTHRU, &
      line=__LINE__, &
      file=__FILE__)) &
      return  ! bail out
        
    call ESMF_ConfigDestroy(cf, rc=rc) ! Destroy the Config
        
    end subroutine read_config

    ! P.Velissariou: Copied this subroutine from
    ! `ADCIRC/src/mesh.F` as modified by Guoming
    !-----+---------+---------+---------+---------+---------+---------+
    ! READ14FEMESH() : Read just mesh
    !  input:
    !      meshfileName = file name
    !  output:
    !      nn = (/ np, ne /)
    !      vx(2,np)   - coordinates of FE nodes
    !      bxy(np)    - bathymetry
    !      etov(3,ne) - Element conectivity table
    !      (optional) nodeLael - node label
    !-----+---------+---------+---------+---------+---------+---------+
    subroutine read14femesh(meshfileName, nn, vx, etov, etog, bxy, nodeLabel)
        use global, only : openFileForRead, nabout, scratchMessage, &
                ERROR, setMessageSource, unsetMessageSource, allMessage
        use hashtable, only : ipair, dict, add_ipair, find, close_dict
        use mesh, only : terminate

        implicit none

        ! dummy
        CHARACTER (LEN = *) :: meshfileName
        INTEGER :: nn(:)
        integer :: n1, n2, n3

        REAL(8), allocatable :: vx(:, :), bxy(:) ! node, bathymetry
        INTEGER, allocatable :: etov(:, :) ! element connectity table, local
        INTEGER, allocatable :: etog(:, :) ! element connectity table, global
        INTEGER, allocatable, optional :: nodeLabel(:)

        ! local
        integer :: i, j, k, jn, je, nhy
        integer, parameter :: iunit = 714
        integer :: ios     ! i/o status
        integer :: lineNum ! line number currently being read
        CHARACTER (LEN = 80) :: agridtmp

        INTEGER :: ne, np, nfluxftmp
        INTEGER, allocatable :: labelstmp(:)

        ! hash table
        ! map node labels to numbers
        type(ipair), allocatable, target :: node_dict_tmp(:)

        call setMessageSource(trim(meshfileName))
#if defined(MESH_TRACE) || defined(ALL_TRACE)
        call allMessage(DEBUG, "Enter.")
#endif

        ! initialization
        lineNum = 1
        nfluxftmp = 0

        call openFileForRead(iunit, trim(meshFileName), ios)

        ! Get dimension
        !  - reading the file
        ! header
        read(iunit, '(A80)', err = 110, end = 120, iostat = ios) &
                agridtmp
        lineNum = lineNum + 1

        ! no. elements, nodes
        read(unit = iunit, fmt = *, err = 110, end = 120, &
                iostat = ios) ne, np
        lineNum = lineNum + 1 ;

        nn(1) = np
        nn(2) = ne

        ! Allocate memory for the
        IF (allocated(vx)) THEN
            DEALLOCATE(vx)  ;
        END IF
        IF (allocated(etov)) THEN
            DEALLOCATE(etov) ;
        END IF
        IF (allocated(etog)) THEN
            DEALLOCATE(etog) ;
        END IF
        IF (allocated(bxy)) THEN
            DEALLOCATE(bxy)  ;
        END IF
        ALLOCATE(vx(2, np), bxy(np), etov(3, ne), etog(3, ne)) ;

        IF (present(nodeLabel)) THEN
            IF (allocated(nodeLabel)) THEN
                DEALLOCATE(nodeLabel)  ;
            END IF
            ALLOCATE(nodeLabel(np))  ;
        END IF

        ! Intialize a hash table
        call dict(node_dict_tmp, np) ;

        !  N O D E   T A B L E
        ALLOCATE(labelstmp(np)) ;
        do k = 1, np
            read(unit = iunit, fmt = *, err = 110, end = 120, &
                    iostat = ios) labelstmp(k), vx(1, k), vx(2, k), &
                    bxy(k)
            lineNum = lineNum + 1
            call add_ipair(node_dict_tmp, labelstmp(k), k)
        enddo
        IF (present(nodeLabel)) THEN
            DO k = 1, np
                nodeLabel(k) = labelstmp(k)  ;
            END DO
        END IF

        !  E L E M E N T   T A B L E
        do k = 1, ne
            read(unit = iunit, fmt = *, err = 110, end = 120, &
                    iostat = ios) je, nhy, n1, n2, n3

            ! Global Ids
            etog(1, k) = n1
            etog(2, k) = n2
            etog(3, k) = n3

            ! Local Ids
            etov(1, k) = find(node_dict_tmp, n1)
            etov(2, k) = find(node_dict_tmp, n2)
            etov(3, k) = find(node_dict_tmp, n3)

            lineNum = lineNum + 1
        enddo

        ! close file
        close(iunit) ;
        call close_dict(node_dict_tmp) !

        ! free memory
        deallocate(labelstmp) ;

        !! populate the adcirc arrays that are used during execution
        !call populateADCIRCNativeArrays()
        !
        !call logMessage(INFO,'Finished reading mesh file coordinates, ' &
        !        // 'connectivity, and boundary data.')

#if defined(MESH_TRACE) || defined(ALL_TRACE)
        call allMessage(DEBUG, "Return.")
#endif
        call unsetMessageSource() ;

        return

        ! jump to here on error condition during read
110     write(scratchMessage, 140) lineNum, ios
140     format('Reading line ', i0, ' gave the following error code: ', &
            i0, '.')
        call allMessage(ERROR, scratchMessage)
        close(iunit)
        call terminate()

        ! jump to here on end condition during read
120     write(scratchMessage, 150) lineNum
150     format('Reached premature end of file on line ', i0, '.')
        call allMessage(ERROR, scratchMessage)
        close(iunit)

        ! free memory
        deallocate(labelstmp) ;

        call close_dict(node_dict_tmp)
        call terminate()

        !----------------------------------------------------------------
    end subroutine read14femesh
    !----------------------------------------------------------------


end module
